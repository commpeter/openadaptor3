<html>
  
  <head>
    <title>openadaptor3 FAQ (versions 3.2.1+)</title>
      <STYLE TYPE="text/css">
        .shell    { width: 90%; background-color: #EEEEEE }
        .heading  { width:100%; font-size:14pt; font-weight:bold; border-bottom-style:solid; border-bottom-width:1px; margin-top:40 }
        .back     { text-align: right; font-size:9pt }
      </STYLE>
  </head>
  
  <body>
    <a id="contents"></a>
    <h1>Frequently Asked Questions (versions 3.2.1+)</h1>

    <h3>1. Basics</h3>
    <ol>
      <li><a href="#versions">Versions of OpenAdaptor</a></li>
      <li><a href="#gettingstarted">Getting started</a></li>
      <li><a href="#typicaldevsteps">Typical developments steps</a></li>
      <li><a href="#classpath">How should I set my classpath?</a></li>
      <li><a href="#xmlconfig">What are in these XML config files?</a></li>
      <li><a href="#payloadneutral">What does "payload neutral" mean for me?</a></li>
      <li><a href="#xsltregexp">Can I transform an XML payload using a regular expression in XSLT?</a></li>
      <li><a href="#customcomponents">What about custom components?</a></li>
    </ol>

    <h3>2. Control Flow and Scripting</h3>
    <ol>
      <li><a href="#pipevrouter">Should I use a Pipeline or a Router?</a></li>
      <li><a href="#loggingrecords">How do I write out intermediate processing results or discarded data?</a></li>
      <li><a href="#exceptions">How do I handle Exceptions?</a></li>
      <li><a href="#logging">How does logging work?</a></li>
      <li><a href="#hospital">How do I hospitalise problematic records?</a></li>
      <li><a href="#javascriptnulls">How do I handle <code>null</code> or missing record keys in JavaScript?</a></li>
      <li><a href="#scriptregexp">Can I modify/filter a Map or XML payload using a JavaScript regular expression?</a></li>
      <li><a href="#javascriptarrays">Can I use JavaScript arrays?</a></li>
      <li><a href="#javascriptfunctions">Can I use JavaScript functions?</a></li>
      <li><a href="#javascriptcompilation">Is the JavaScript precompiled?</a></li>
      <li><a href="#scriptingcomponents">Can my JavaScript invoke other OpenAdaptor components?</a></li>
      <li><a href="#scriptscontrolflow">Can I use JavaScript control flow inside my JavascriptProcessor scripts?</a></li>
      <li><a href="#filterorcondition">Should I use a Filter or If-Condition-Else components or JavaScript?</a></li>
    </ol>

    <h3>3. Working with XML config files</h3>
    <ol>
      <li><a href="#eclipsesetup">How do I set up the Eclipse IDE to work with OpenAdaptor?</a></li>
      <li><a href="#eclipsexml">How can Eclipse IDE help me to write my adaptors?</a></li>
      <li><a href="#docgen">How can I generate documentation and pictures for my adaptors?</a></li>
      <li><a href="#variables">How do I set variables from a separate properties file or on the command line?</a></li>
      <li><a href="#singleadaptormultiplefiles">How can I split a single adaptor across multiple XML files?</a></li>
      <li><a href="#multipleadaptorssinglefile">How can I host multiple adaptors in a single XML file?</a></li>
      <li><a href="#runtimeparameters">How do I get JDBCReadConnector to pick up its input parameters at runtime?</a></li>
    </ol>

    <h3>4. Services and Other topics</h3>
    <ol>
      <li><a href="#jmsdoxml">Can I still Subscribe to JMS Messages published in DOXML by an OA1.x Publisher?</a></li>
      <li><a href="#registeringadaptors">How can I register centrally which adaptors are running?</a></li>
      <li><a href="#running">How can I run an adaptor as an NT Service?</a></li>
      <li><a href="#daemon">How can I run an adaptor as daemon process?</a></li>
    </ol>

    <h3>5. Getting hold of it</h3>
    <ol>
      <li><a href="#downloading">How do I Download it?</a></li>
      <li><a href="#examplesbrowsing">Can I browse the Examples/Tutorial online?</a></li>
      <li><a href="#javadocbrowsing">Can I browse the JavaDoc online?</a></li>
      <li><a href="#sourcebrowsing">Can I browse the Source Code online?</a></li>
      <li><a href="#eclipsesvn">How do I use Eclipse to checkout the source code? (Subclipse)</a></li>
      <li><a href="#tortoisesvn">Is there a Windows client for checkingout the source code? (TortoiseSVN)</a></li>
      <li><a href="#eclipsetortoiseversions">Which versions of Subclipse and TortoiseSVN work together?</a></li>
    </ol>


    <hr>
    <h1>Basics:</h1>
    <!-- Basics: -->
    <!-- Basics: -->
    <!-- Basics: -->

    <a id="versions"></a>
    <h2>Versions of OpenAdaptor</h2>
    <p>
      OpenAdaptor has a long history, and we are now putting all of our development effort
      into the OpenAdaptor&nbsp;3.2.1+ codebase.
    </p>
    <p>
      All other versions are now either in legacy maintenance mode (1.7.2.2) or no longer supported.
      Legacy maintenance mode means that our community is still actively helping people with queries,
      and that we are only patching significant bugs.
    </p>
    <p>
      The supported migration path for legacy adaptors is to upgrade to 1.7.2.2 and then move to 3.2.1+.
    </p>
    <table border="1">
      <tr>
        <th>Version</th>
        <th>Project URL</th>
        <th>Status</th>
        <th>Comment</th>
      </tr>
      <tr>
        <td>OpenAdaptor&nbsp;3.2.1+</td>
        <td>https://openadaptor3.openadaptor.org</td>
        <td>
          <table>
            <tr><td>ACTIVE (Fully SUPPORTED)</td></tr>
            <tr><td>We are committed to developing this codebase further.</td></tr>
          </table>
        </td>
        <td>
          Subversion project we are actively developing.
          We are already using it in production.
        </td>
      </tr>
      <tr>
        <td>OpenAdaptor&nbsp;1.x</td>
        <td>https://openadaptor.openadaptor.org</td>
        <td>
          <table>
            <tr><td>LEGACY (SUPPORTED)</td></tr>
            <tr><td>Migrate to 1.7.2.2, and then to OpenAdaptor&nbsp;3.2.1+.</td></tr>
          </table>
        </td>
        <td>
          CVS project in legacy maintenance mode.
          We are still using it in production (with a migration programme underway).
        </td>
      </tr>
      <tr>
        <td>OA3.0, OA3.1</td>
        <td>https://oa3.openadaptor.org</td>
        <td>
          <table>
            <tr><td>UNSUPPORTED (prototype)</td></tr>
            <tr><td>Migrate immediately to 3.2.1+</td></tr>
          </table>
        </td>
        <td>
          CVS project used for prototyping: completely superceded by OpenAdaptor&nbsp;3.2.1+ codebase.
          Migration is straightforward.
        </td>
      </tr>
    </table>
    <p>
      If you are migrating legacy OpenAdaptor&nbsp;1.x adaptors you may encounter
      <a href="#customcomponents">custom components</a> which may now be supported by standard
      componentry in OpenAdaptor&nbsp;3.2.1+.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="gettingstarted"></a>
    <h2>Getting started</h2>
    <p>We recommend following these steps</p>
    <ol>
      <li>read the <a href="http://www.openadaptor.org/docs/whitepaper.pdf">whitepaper</a></li>
      <li>download the binary distribution from <a href="http://www.openadaptor.org/downloads.html">downloads</a></li>
      <li>unzip</li>
      <li>do the tutorial, contained in the distribution (example/tutorial/index.html)</li>
      <li>read the general README (example/readme.html)</li>
      <li>explore the spring examples, contained in the distribution (example/spring)</li>
    </ol>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="typicaldevsteps"></a>
    <h2>Typical developments steps</h2>
    <p>
      Fundamentally an adaptor is a process that takes data from one place and puts it in another.
      These places can be datastores (e.g. SQL database; filesystem) or enterprise buses (e.g. JMS; MQ).
      The data may also be transformed and/or filtered by the adaptor.
    </p>
    <p>
      Writing a new adaptor is best done as an incremental process.
      Start at one (or sometimes both) ends and test as you go along.
    </p>
    <ol>
      <li>
        Analyse basic requirements (input; transformation; output(s); logging).
      </li>
      <li>
        Get development environment set up so it can run a trivial example adaptor.
      </li>
      <li>
        Create your new XML config file based on a skeleton file like the
        <a href="#xmlconfig">XML config example</a> below, with an empty Router.
      <li>
        Add components that reads date from your input and writes to a file
        (the file writing component will try to sensibly represent the data).
      </li>
      <li>
        Run your adaptor, and examine the output.
        Have you successfully captured the input data?
      </li>
    </ol>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="classpath"></a>
    <h2>How should I set my classpath?</h2>
    <p>openadaptor lib directory contains the following</p>
    
    <table>
      <tr><td><b>log4j.properties</b></td><td>A sample log4j configuration file</td></tr>
      <tr><td><b>openadaptor.jar</b></td><td>The actual openadaptor code</td></tr>
      <tr><td><b>openadaptor-spring.jar</b></td><td>Helper classes for launching openadaptor processes based on spring configurations</td></tr>
      <tr><td><b>openadaptor-depends.jar</b></td><td>Most of the 3rdparty jars, re-jarred as a single jar for convenience</td></tr>
      <tr><td><b>3rdparty</b></td><td>The 3rd party jars</td></tr>
    </table>
    
    <p>Your classpath needs to contain <b>openadaptor.jar</b>. If you are using our spring helper
    classes to run an adaptor / application then you will need <b>openadaptor-spring.jar</b>. You will also
    need a subset of the 3rdparty jars upon which openadaptor relies, the easist approach is to include
    <b>openadaptor-depends.jar</b>. So your classpath would be something like this...</p>
    
    windows
    <div class="shell"><pre>  set CLASSPATH=lib;lib/openadaptor.jar;lib/openadaptor-spring.jar;lib/openadaptor-depends.jar</pre></div>
    
    *nix
    <div class="shell"><pre>  CLASSPATH=lib:lib/openadaptor.jar:lib/openadaptor-spring.jar:lib/openadaptor-depends.jar
  export CLASSPATH</pre></div>
    
    <p>example/bin contains a windows bat script and a bash profile that sets your CLASSPATH like this.
      However you may decide to include just the 3rdparty jars that you need which is why we include the 3rdparty directory.</p>
    
    <p>post release 3.2.1, openadaptor comes with an additonal jar called <b>bootstrap.jar</b>. This contains
    alternative helper classes that will bootstrap the classpath based on the location of the bootstrap.jar.
    All you need in your classpath is bootstrap.jar. You can dump out the programs that can be run
    from this bootstrap.jar like this</p>

    <div class="shell"><pre>  java -jar bootstrap.jar</pre></div>
    
    <p>This should print something like the following...</p>
    
    <div class="shell"><pre>  This jar contains the following programs :
    org.openadaptor.bootstrap.FileSystemExceptionManager
    org.openadaptor.bootstrap.JDBCExceptionManager
    org.openadaptor.bootstrap.SpringAdaptor
    org.openadaptor.bootstrap.SpringApplication
  When you run these they will bootstrap the classpath based on the location of this jar
  use -Dopenadaptor.lib=... to provide an additional location to search for classpath resources</pre></div>
    
    <p>These bootstrapping programs will automatically construct the classpath based on the location
    of the bootstrap.jar. The classpath will contain all the jars, zip and subdirectories. You can specify an additional directory
    to search using the openadaptor.lib system property. <b>patch.jar</b> will always be placed at the
    front of the classpath, it will load the contents of 3rdparty rather than openadaptor-depends.jar,
    openadaptor-stub.jar will always be at the end of the classpath.</p>
    
    <p>example 1:</p>
    <div class="shell"><pre>   java -classpath lib\bootstrap.jar org.openadaptor.bootstrap.SpringAdaptor -config foo.xml</pre></div>
    
    <p>example 2:</p>
    <div class="shell"><pre>  SET CLASSPATH=lib\bootstrap.jar
  java org.openadaptor.bootstrap.SpringAdaptor -config foo.xml</pre></div>
    
    <p>example 3:</p>
    <div class="shell"><pre>  SET CLASSPATH=lib\bootstrap.jar
  java -Dopenadaptor.lib=c:\tibco\tibrv\lib org.openadaptor.bootstrap.SpringAdaptor -config tibco.xml</pre></div>
    
    <p>
      <b>Note: The command line syntax is under review following release of version 3.2.1,
      and so the syntax might change in the next release.</b>
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>
    

    <a id="xmlconfig"></a>
    <h2>What are in these XML config files?</h2>
    <p>
      The XML files are Spring 2.0 configuration files.
      The OpenAdaptor 3.x components have been written as Spring "beans".
    </p>
    <p>
      Please make use of the Spring &lt;description&gt; element as illustrated here.
      This allows you to insert descriptive comments in your code for beans and for each of their properties.
      Our <a href="#docgen">documentation and picture generation</a> exploits the presence of the descriptions.
    </p>
    <p>
      Here is a boilerplate example, which includes a non-trivial routing table:
    </p>
    <div class="shell"><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--
  Documentation generation currently relies on having a HeadURL svn:property
  (due to limitation of XSLT 1.1 in that it does not know name/path of file it is processing)
  which must be between the "xml version" first line and the "beans" element
  (which in turn must refer to the Spring 2.0 XML Schema Description).
  
  $Id: $
  $HeadURL: $
--&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;

  &lt;description&gt;&lt;![CDATA[
  Minimal example.
  
  Just shows XML fragments that should always be there (in some form or other).
  
  The XML files are Spring 2.0 configuration files.
  The OpenAdaptor 3.x components have been written as Spring "beans".
  
  Read the rest of the FAQ to learn more about working with these XML files.
  ]]&gt;&lt;/description&gt;


  &lt;bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor"&gt;
    &lt;description&gt;
      This is the bean that actually gets run.
      It is possible to have several in one XML config file, and then to tell adaptor which one to run on command line.
      We would recommend having exactly one of these per XML config file.
    &lt;/description&gt;
    &lt;property name="messageProcessor" ref="Router" /&gt;
  &lt;/bean&gt;


  &lt;bean id="Router" class="org.openadaptor.core.router.Router"&gt;
    &lt;description&gt;
      The adaptor delegates it's message processing to a router.
      The router uses this mapping to define the "processing pipeline".

      Main control flow is:
        Reader -&gt; Filter -&gt; Modifier |-&gt; DatabaseWriter
                                     |-&gt; FileLogger

      However, anything that is discarded by the Filter will then go:
        DiscardedFormatter -&gt; DiscardedWriter

      And ProcessingExceptions thrown by Filter (and subsequent nodes) are sent to FailedParsingLogger,
      except those thrown by DatabaseWriter which are sent to FailedWritesLogger.
    &lt;/description&gt;
    &lt;property name="processMap"&gt;
      &lt;map&gt;
        &lt;entry key-ref="Reader" value-ref="Filter" /&gt;

        &lt;entry key-ref="Filter" value-ref="Modifier" /&gt;

        &lt;entry key-ref="Modifier"&gt;
          &lt;list&gt;
            &lt;ref bean="DatabaseWriter" /&gt;
            &lt;ref bean="FileLogger" /&gt;
          &lt;/list&gt;
        &lt;/entry&gt;
        
        &lt;!--  Other subsidiary pipelines: --&gt;
        &lt;entry key-ref="DiscardedFormatter" value-ref="DiscardedWriter" /&gt;        
      &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name="discardMap"&gt;
      &lt;map&gt;
        &lt;entry key-ref="Filter" value-ref="DiscardedFormatter" /&gt;
      &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name="exceptionMap"&gt;
      &lt;description&gt;Catch input parsing problems and bad writes here...&lt;/description&gt;
      &lt;map&gt;
        &lt;entry key-ref="Filter"&gt;
          &lt;map&gt;
            &lt;entry key="org.openadaptor.core.exception.ProcessingException" value-ref="FailedParsingLogger" /&gt;
          &lt;/map&gt;
        &lt;/entry&gt;
        &lt;entry key-ref="DatabaseWriter"&gt;
          &lt;map&gt;
            &lt;entry key="org.openadaptor.core.exception.ProcessingException" value-ref="FailedWritesLogger" /&gt;
          &lt;/map&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  &lt!-- Definitions of all of the beans referred to in the routing table come here. --&gt;
&lt;/beans&gt;</pre></div>
    <p>
      You can see an XML config fragment below for <a href="#jmsdoxml">reading legacy JMS DOXML</a>
      which shows a routing table and almost all of the beans referred to by it.
      Note the way that we use <code>id</code> attribute to name and refer to beans:
      this is the way that Spring works (and XML states that <code>id</code> is unique within file).
    </p>
    <p>
      Spring also allows <code>name</code> attribute to be used to provide aliases, but
      we would advocate avoiding using this unless absolutely necessary (as you will get
      much poorer support from XML editing tools and XML Validation will not be able to
      spot some obvious bugs on your behalf).
    </p>
    <p>
      Some bean ids will not be mentioned in the Router, e.g.
    </p>
    <ul>
      <li>Helper bean nested inside a top-level bean.</li>
      <li>Helper bean at top-level and referred to directly/indirectly by a bean referred to in the Router.</li>
      <li>Beans whose presence simply has the side effect of configuring adaptor services.</li>
    </ul>
    <p>
      Examples of the last category are
      <a href="#variables">Spring's PropertyPlaceholderConfigurer bean</a>
      and
      <a href="#registeringadaptors">OpenAdaptor's central registration config</a>.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="payloadneutral"></a>
    <h2>What does "payload neutral" mean for me?</h2>
    <p>
      In OpenAdaptor version 1.x all data records were passed around as a custom Java type called DataObject.
      Incoming data had to be a DataObject before it could be processed.
    </p>
    <p>
      In OpenAdaptor version 3.0+ we have thrown away that restriction, and the data records passed
      around simply needs to be of standard Java type Object.
    </p>
    <p>
      So you can read data in from one place and write it out to another, without ever needing to
      map it to a different representation.
      This avoids conversions that are lossy (non-idempotent) or pointless (excess processing overhead).
    </p>
    <p>
      A good example of this is reading an XML record in from one place and writing an XML record
      out to another place, perhaps having modified it using an XSLT transform or one of our
      other components that can work with XML payloads, and treating it as an XML document throughout.
    </p>
    <p>
      An objective of OpenAdaptor is to promote reuse of standard components, and so we had to
      settle on some standard payload formats to target our components at.  (Note this is just a
      necessary restriction as to what individual components can handle: the framework itself is payload neutral).
    </p>
    <p>
      We support a variety of payload formats, but with a special emphasis on Maps and XML.
      (We are actively working on further improving/harmonising this area for post 3.2.1 releases.)
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="xsltregexp"></a>
    <h2>Can I transform an XML payload using a regular expression in XSLT?</h2>
    <p>
      No.  Whilst XSLT 1.1 has substring functions it lacks regular expression support.
    </p>
    <p>
      Instead you use one of our standard scripting components to
      <a href="#scriptregexp">modify/filter using a JavaScript regular expression</a>.
    </p>
    <p>
      There is no need to use an <code>org.openadaptor.auxil.convertor.xml.XmlToOrderedMapConvertor</code>
      component because our standard modify/filter components understand XML payloads too.
    </p>
    <p>
      The OpenAdaptor XSLT component will meet most of your other XML transformation needs,
      especially when reading XML in and writing XML out.
    </p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="customcomponents"></a>
    <h2>What about custom components?</h2>
    <p>
      All versions of OpenAdaptor provide a suite of reusable components.
      They can connect to datastores, and can process/filter data on its way through your adaptor.
    </p>
    <p>
      Similarly all versions of OpenAdaptor allow you to provide your own custom components.
    </p>
    <p>
      In OpenAdaptor 3.2.1+ we have:
    </p>
    <ul>
      <li>
        Reduced the need to write custom Processor components.
        We examined hundreds of adaptors written by others and found that most of the custom components
        were simply applying some business logic to manipulate attributes.
        <ul>
          <li>
            <code>JavascriptProcessor</code> and <code>JavascriptFilterProcessor</code>
            allow custom attribute manipulation to be expressed inside the adaptor XML config file.
          </li>
          <li>
            XML payloads are handled natively by OpenAdaptor 3.2.1+, both by general purpose
            components and by XML specific components such as <code>XsltProcessor</code>.
          </li>
        </ul>
      </li>
      <li>
        Made it easier to write custom Processor components.
        Now you just need to concentrate on your custom transformation logic,
        whereas in OpenAdaptor 1.x you also had to correctly code
        some boiler plate data marshalling logic.
      </li>
    </ul>
    <p>
      As a rule of thumb, it is best to avoid/minimise using custom components as it makes
      it easier to support/maintain your adaptor long term.
    </p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <hr>
    <h1>Control flow:</h1>
    <!-- Control flow: -->
    <!-- Control flow: -->
    <!-- Control flow: -->

    <a id="pipevrouter"></a>
    <h2>Should I use a Pipeline or a Router?</h2>
    <p>
      You must use a Router if you have multiple routes through an adaptor.
    </p>
    <p>
      The Pipeline provides a terser syntactic sugar for adaptors with a single route.
    </p>
    <p>
      So in general we would recommend that you start with a Router for production strength adaptors.
    <p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="loggingrecords"></a>
    <h2>How do I write out intermediate processing results or discarded data?</h2>
    <p>
      Use a Router rather than a Pipeline.
      In the Router you can say where all data goes to regardless of whether it is successfully processed
      (unlike in OpenAdaptor 1.x where you had the tricky task of writing
      a second inverted-logic filter to catch discarded data).
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="exceptions"></a>
    <h2>How do I handle Exceptions?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="logging"></a>
    <h2>How does logging work?</h2>
    <p>We use Apache Commons logging abstraction in our classes, and typically behind that we use Log4j at runtime.</p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>


    

    <a id="hospital"></a>
    <h2>How do I hospitalise problematic records?</h2>
    <p>
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="javascriptnulls"></a>
    <h2>How do I handle <code>null</code> or missing record keys in JavaScript?</h2>
    <p>
      It is your responsibility to explicitly handle <code>null</code> or missing record keys in JavaScript.
    </p>
    <p>
      Typically you do this by using guard clauses that test for <code>null</code> in JavaScript
      before operating on the value.
    </p>
    <p>
      JavaScript will see a <code>null</code> value when you call <code>record.get(keyname)</code>
      regardless of whether (a) the key exists and is bound to a null value in the record,
      or (b) the key does not exist in the record.
    </p>
    <p>
      You can descriminate between cases (a) and (b) using the <code>record.containsKey(keyname)</code> method.
    </p>
    <div class="shell"><pre>  &lt;bean id="FilterDateOfBirth" class="org.openadaptor.auxil.processor.javascript.JavascriptProcessor"&gt;
    &lt;description&gt;
      Set 'dobstatus' attribute according to presence and value of 'dateofbirth' attribute.
    &lt;/description&gt;
    &lt;property name="script"&gt;
      dob = record.get('dateofbirth');
      if (dob == null) {
        if (record.containsKey('dateofbirth')) {
          found = "present and explicitly null";
        } else {
          found = "missing and implicitly null";
        }
      } else {
        found = "present and not null";
      }
      record.set('dobstatus',found);
    &lt;/script&gt;
  &lt;/bean&gt;</pre></div>     <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="scriptregexp"></a>
    <h2>Can I modify/filter a Map or XML payload using a JavaScript regular expression?</h2>
    <p>
      Yes.  You can use JavaScript regular expressions in the <code>script</code> property
      of:
    </p>
    <ul>
      <li><code>org.openadaptor.auxil.processor.javascript.JavascriptProcessor</code></li>
      <li><code>org.openadaptor.auxil.processor.javascript.JavascriptFilterProcessor</code></li>
    </ul>
    <div class="shell"><pre>  &lt;bean id="SetBirthYear" class="org.openadaptor.auxil.processor.javascript.JavascriptProcessor"&gt;
    &lt;description&gt;
      Updates the 'birthyear' attribute with the result of extracting year from 'dateofbirth' attribute.
      
      Uses JavaScript regular expression to parse and takes first capture group as result.
    &lt;/description&gt;
    &lt;property name="script"&gt;
      record.put('birthyear',/(\d{4})-(\d{1,2})-(\d{1,2})/.exec(record.get('dateofbirth'))[1]/;
    &lt;/script&gt;
  &lt;/bean&gt;</pre></div> 
  
  
  XXXXXXXXXXXXXXXXX     Filter with a match example
  
    <p class="back"><a href="#contents">back to contents</a></p>


    
    <a id="javascriptarrays"></a>
    <h2>Can I use JavaScript arrays?</h2>
    <p>
      Yes (added for OpenAdaptor 3.2.1.1).
    </p>
    <p>
      In your script you use <code>record.get()</code>, <code>record.set()</code>
      and <code>record.put()</code> where the value is a JavaScript native array.
    </p>
    <div class="shell"><pre>  &lt;bean id="ParseAddress" class="org.openadaptor.auxil.processor.javascript.JavascriptProcessor"&gt;
    &lt;description&gt;
      Split address string into an array of strings on ',' characters.
      Input address='National Maritime Museum, Greenwich, LONDON SE10 9NF';
      Output address={'National Maritime Museum',' Greenwich',' LONDON SE10 9NF'};
    &lt;/description&gt;
    &lt;property name="script"&gt;
      address = record.get('address');
      if (address != null) {
        record.set('address', address.split(','));
      }
    &lt;/property&gt;
    &lt;property name="discardMatches" value="false" /&gt;
  &lt;/bean&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="javascriptfunctions"></a>
    <h2>Can I use JavaScript functions?</h2>
    <p>
      Yes, their scope is the script in which they are defined.
    </p>
<!--    <div class="shell"><pre>  </pre></div>-->
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="javascriptcompilation"></a>
    <h2>Is the JavaScript precompiled?</h2>
    <p>
      Yes, by default the JavaScript is compiled at adaptor load time.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="scriptingcomponents"></a>
    <h2>Can my JavaScript invoke other OpenAdaptor components?</h2>
    <p>
      No, because this goes against the clean architecture of OpenAdaptor.
    </p>
    <p>
      Instead you should use the <a href="filterorcondition">filter components or the if-then-else components</a>.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="scriptscontrolflow"></a>
    <h2>Can I use JavaScript control flow inside my JavascriptProcessor scripts?</h2>
    <p>
      Yes.  You write JavaScript in the normal way, and operate on the <code>record</code> passed in
      which also doubles as the result object.
    </p>
    <p>
      Your condition expressions will typically involve data extracted from each incoming record.
      It can also involve <a href="#variables">variables from a separate properties file or command line</a>
      which are specific to this executing instance of the adaptor: these are evaluated when the adaptor
      is loaded and thereafter behave as literal string values.
    </p>
    <p>
      As a design guideline we very strongly advocate avoiding writing long pieces of JavaScript (a screenful is long).
      Instead break down your JavaScript into small blocks of defined functionality and place each
      in a separate <code>JavaScriptProcessor</code>.
      This makes it much easier to unit-test each piece of logic (we plan to provide some practical
      help with this at the component level in the future) according to expected inputs and outputs.
      It also allows you to take advantage of the discard and exception routing support of OpenAdaptor.
      Note that hosting it in multiple components may mean using <code>JavascriptFilterProcessor</code>
      components to express branching logic as well as <code>JavascriptProcessor</code> components.
    </p>
    <div class="shell"><pre>  &lt;bean id="DiscountedTrainFare" class="org.openadaptor.auxil.processor.javascript.JavascriptProcessor"&gt;
    &lt;description&gt;Calcuate train fare discount applicable based on age (and for illustration) gender.&lt;/description&gt;
    &lt;property name="script"&gt;
      // examine incoming object:
      age = record.get('age');
      gender = record.get('gender');
      
      // assume full fare:
      percentage = 100;
      
      if (age != null) {
        // no discount available unless we know their age ;-)
        if (age &lt; 2) {
          percentage = 0; // infants travel free
        } else if (age &lt;= 16) {
          percentage = 50; // children half-price
        } else {
          if ((gender != null) &amp;&amp; (gender == 'female') &amp;&amp; (age &gt;= ${myprop.pension.age.female})) {
            // women over 60
            percentage = 66;
          } else if (age &gt;= ${myprop.pension.age.male}) {
            // everyone over 65  (assumes male pension age same or older than female for brevity)
            percentage = 66;
          }
        }
      }
      
      // modify outgoing object:
      record.set('rate',percentage);
    &lt;/property&gt;
    &lt;property name="discardMatches" value="false" /&gt;
  &lt;/bean&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="filterorcondition"></a>
    <h2>Should I use a Filter or If-Condition-Else components or JavaScript?</h2>
    <p>
      It depends: use the one that is most suitable.
      It is reasonable to combine them.
      You should be guided by what makes your intent clearest (both in the XML config and
      in the <a href="#docgen">generated node map images</a>).
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <hr>
    <h1>Working with XML config files:</h1>
    <!-- Working with XML config files: -->
    <!-- Working with XML config files: -->
    <!-- Working with XML config files: -->

    <a id="eclipsesetup"></a>
    <h2>What Eclipse IDE Features should I install?</h2>
    <p>
      This section explains what "Eclipse Features" to install.
      A later section explains the <a href="#eclipsexml">benefits and how to use them</a>.
    </p>
    <p>
      Click Help &gt; Software Updates &gt; Find and Install (you can use Manage Configuration
      if instead you want to inspect what is already installed).
    </p>
    <p>
      http://springide.org/project/wiki/SpringideCallistoInstall
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>


    
    <a id="eclipsexml"></a>
    <h2>How can Eclipse IDE help me to write my adaptors?</h2>
    <p></p>
    <ul>
      <li>XML syntax colouring and completion</li>
      <li>Spring Schema completion and navigation to bean definitions by "id"</li>
      <li>OpenAdaptor classes (source and JavaDoc)</li>
      <li>OpenAdaptor properties (completion and JavaDoc)</li>
      <li></li>
      <li>Running adaptor XML files directly from within Eclipse.</li>
      <li>Generating documentation and images from your adaptor XML config file.</li>
      <li></li>
      <li></li>
    </ul>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>


    
    <a id="docgen"></a>
    <h2>How can I generate documentation and pictures for my adaptors?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="variables"></a>
    <h2>How do I set variables from a separate properties file or on the command line?</h2>
    <p>
      You can define whichever properties you like and you have options in configuring the
      <a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-factory-placeholderconfigurer">PropertyPlaceholderConfigurer</a>.
    </p>
    <div class="shell"><pre>  &lt;bean id="SystemPropertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="ignoreResourceNotFound" value="true" /&gt;
    &lt;property name="systemPropertiesMode"&gt;
      &lt;bean id="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
    &lt;/property&gt;
    &lt;property name="locations"&gt;
      &lt;description&gt;
        Properties set by a file in list below are supposedly overridden by settings in a file later in list below.
      &lt;/description&gt;
      &lt;list&gt;
        &lt;value&gt;classpath:general.properties&lt;/value&gt;
        &lt;value&gt;classpath:specific.properties&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</pre></div>
    <p>
      The above PropertyPlaceholderConfigurer configuration says to pick up these values
      from the two specified Java Properties files, and to ovveride these settings with
      values found in the Java SystemProperties (typically set with <code>-Dname=value</code>
      command line options).
    </p>
    <p>
      You then access the properties as <code>${myPropertyName}</code> within your XML config file.
    </p>
    <p>
      See <a href="#runtimeparameters">runtime parameters</a> example below.
    </p>  
    <p>
      This parameterisation technique is also very valuable as it allows you to deploy
      the same XML config file with different Java Properties files in Development/Test/Production.
      That also then allows you to then publish your XML config file without fear of exposing passwords
      as these will be in the environment specific Java Properties files.
    </p>
    <p>
      <b>Note: We are planning to make this easier in the release after 3.2.1 (e.g. automatic detection of
      <code>-D</code> properties causing a default PropertyPlaceholderConfigurer to be created in memory
      if there is no user specified one).</b>
    <p>  
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="singleadaptormultiplefiles"></a>
    <h2>How can I split a single adaptor across multiple XML files?</h2>
    <p>
      These are Spring XML config files, so you can have multiple files that are combined together in a single adaptor.
    </p>
    <p>
      Spring defines that each of these XML files must be a proper Spring XML file (including <code>&lt;beans&gt;</code> top-level element).
    </p>
    <p> 
      There are two different ways that you can combine them:
    </p>
    <ol>
      <li>
        Supply multiple XML filenames as SpringAdaptor command line arguments <b>(recommended)</b>.
      </li>
      <li> 
        Use the <code>&lt;import resource="someFile.xml"/&gt;</code> element (must be first element(s)
        after <code>&lt;beans&gt;</code> tag of importing XML file) and then just supply the importing
        XML filename on SpringAdaptor command line.
      </li>
    </ol>
    <p>
      Your different files will each contain multiple <code>&lt;bean&gt;</code> elements.
      Each &lt;bean&gt; element should have an <code>id</code> attribute
      (e.g. <code>&lt;bean id="myBean" class="org.openadaptor.Something"/&gt;</code>).
      Then rather than having an in-line bean definition you can have a <code>ref</code>
      (or <code>bean-ref</code>) attribute whose value is the <code>id</code>
      (e.g. <code>&lt;property name="someProperty" ref="myBean"/&gt;</code>).
      You should see how this can be used to share a bean definition between files, and thus across adaptors.
      And so you can achieve what you want provided that you can express it at the bean level.
    </p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>
    


    <a id="multipleadaptorssinglefile"></a>
    <h2>How can I host multiple adaptors in a single XML file?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
    


    <a id="runtimeparameters"></a>
    <h2>How do I get JDBCReadConnector to pick up its input parameters at runtime?</h2>
    <p>
      You can have a JDBCReadConnector, which executes a dynamic query,
      i.e. a query which reads input parameters at runtime via command line or property file.
    </p>
    <div class="shell"><pre>  &lt;bean id="Reader" class="org.openadaptor.auxil.jdbc.reader.JDBCReadConnector"&gt;
    &lt;property name="jdbcConnection" ref="JdbcConnection"/&gt;
    &lt;property name="sql" value="Select * from dbo.mydata where valid_from &gt; ${start} And valid_from &lt; ${end}"/&gt;
  &lt;/bean&gt;</pre></div>
    <p>
      You then configure a PropertyPlaceholderConfigurer and pass in data as defined in
      <a href="#variables">variables setting section</a> above.      
    </p>
    <p>
      So then you could start your adaptor as follows:
    </p>
    <div class="shell"><pre>  java -Dstart=whatever -Dend=whatever org.openadaptor... etc</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
 


    <hr>
    <h1>Services and Other topics</h1>
    <!-- Services and Other topics: -->
    <!-- Services and Other topics: -->
    <!-- Services and Other topics: -->

    <a id="jmsdoxml"></a>
    <h2>Can I still Subscribe to JMS Messages published in DOXML by an OA1.x Publisher?</h2>
    <p>Yes :-)</p>
    <p>
      We have provided a set of components to support this (they offer a useful level of backwards compatability).
      We have tested these components using OpenAdaptor 1.7.2.2,
      and would strongly recommend that you upgrade your publisher to this level first
      (especially if you are using types other than Strings in your DOXML).
    </p>
    <p>The basic dataflow is:</p>
    <ol>
      <li>
        "payload neutral" records are read off the wire by standard OpenAdaptor3 components.
      </li>
      <li>
        Then parsed as DOXML and the body (only) of the message is written out as plain XML by
        a legacy openadaptor1.x component (from an OpenAdaptor 1.x jar on the classpath).
      </li>
      <li>
        Then treated as a vanilla XML payload by standard OpenAdaptor3 components
        <a href="#payloadneutral">(see "payload neutral")</a>
      </li>
    </ol>
    <p>
      <b>::TODO:: Need to describe classpath...</b>
    </p>
    <div class="shell"><pre>  &lt;bean id="Router" class="org.openadaptor.core.router.Router"&gt;
    &lt;description&gt;
      The adaptor delegates it's message processing to a router.
      The router uses this mapping to define the "processing pipeline".

      This routing is deliberately incomplete (just describes reading in the data and parsing it).
      Needs to also describe writing it out too.
      
      When testing the rest of the adaptor (during development or regression) it is very useful
      to be able to re-inject JMS DOXML messages that were previously captured.
      That is what the "DEBUG_" beans are used for.
      You can fan-out the records from the wire so that they are both captured and processed.
      And later you can decide that rather than reading records from the JMS service, you want
      to replay previously captured JMS DOXML/XML messages from file.
      The captured messages also serve as a log of the data sent over the wire, which is very
      useful when you are trying to write parsing/processing components such as XSLT transforms.
    &lt;/description&gt;
    &lt;property name="processMap"&gt;
      &lt;map&gt;
        &lt;!-- Read XML from JMS:--&gt;
        &lt;entry key-ref="MyReader"&gt;
          &lt;list&gt;
            &lt;!-- &lt;ref bean="DEBUG_LogAllDOXMLMessage" /&gt; --&gt;  &lt;!-- in Production MUST comment out this DOXML DEBUG logging line!--&gt;
            &lt;ref bean="DOXmlConvertor" /&gt;
          &lt;/list&gt;
        &lt;/entry&gt;
        
        &lt;!-- Just for DEBUG: read DOXML from DEBUG test file instead of reading from JMS: --&gt;
        &lt;!-- &lt;entry key-ref="DEBUG_DOXMLFileReader" value-ref="DOXmlConvertor" /&gt; --&gt;

        &lt;entry key-ref="DOXmlConvertor" value-ref="DataObjectConvertor" /&gt;

        &lt;entry key-ref="DataObjectConvertor" value-ref="XmlExtractFields" /&gt;

        &lt;entry key-ref="XmlExtractFields" value-ref="XmlToOrderedMapConvertor" /&gt;

        &lt;entry key-ref="XmlToOrderedMapConvertor" value-ref="FilterOnMessageTypeContact" /&gt;

        &lt;!-- More config required: Needs to do any further processing and then write the results somewhere... --&gt;
      &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name="exceptionMap"&gt;
      &lt;description&gt;Catch input parsing problems here...&lt;/description&gt;
      &lt;map&gt;
        &lt;entry key-ref="DOXmlConvertor"&gt;
          &lt;map&gt;
            &lt;entry key="org.openadaptor.core.exception.ProcessingException" value-ref="FailedReadsOutpoint" /&gt;
          &lt;/map&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="MyJndiConnection" class="org.openadaptor.auxil.connector.jndi.JNDIConnection"&gt;
    &lt;property name="initialContextFactory" value="com.sun.jndi.ldap.LdapCtxFactory" /&gt;
    &lt;property name="providerUrl" value="${adaptorprop.jms.jndiconnection.providerurl}" /&gt;
    &lt;property name="securityPrincipal"   value="${adaptorprop.jms.jmsservice.username}" /&gt;
    &lt;property name="securityCredentials" value="${adaptorprop.jms.jmsservice.password}" /&gt;
  &lt;/bean&gt;

  &lt;bean id="MyJmsConnection" class="org.openadaptor.auxil.connector.jms.JMSConnection"&gt;
    &lt;description&gt;JMS connection for queue we wish to subscribe to.&lt;/description&gt;
    &lt;property name="jndiConnection" ref="MyJndiConnection" /&gt;
    &lt;property name="connectionFactoryName" value="${adaptorprop.jms.jmsconnection.connectionfactoryname}" /&gt;
    &lt;property name="username" value="${adaptorprop.jms.jmsconnection.username}" /&gt;
    &lt;property name="password" value="${adaptorprop.jms.jmsconnection.password}" /&gt;
  &lt;/bean&gt;


  &lt;bean id="MyReader" class="org.openadaptor.auxil.connector.jms.JMSReadConnector"&gt;
    &lt;description&gt;Reader that polls a JMS queue.&lt;/description&gt;
    &lt;property name="destinationName" value="cn=someTopic" /&gt;
    &lt;property name="jmsConnection" ref="MyJmsConnection" /&gt;
    &lt;property name="transacted" value="true" /&gt;
    &lt;property name="durable" value="${adaptorprop.jms.jmsreadconnector.durable}" /&gt;
    &lt;property name="durableSubscriptionName" value="${adaptorprop.jms.jmsreadconnector.durablesubscriptionname}" /&gt;
  &lt;/bean&gt;


  &lt;bean id="DEBUG_LogAllDOXMLMessage" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector"&gt;
    &lt;description&gt;Just for writing out data to use for DEBUG (raw DOXML).&lt;/description&gt;
    &lt;property name="filename" value="${somePath}/logs/${adaptorprop.timestamp}-0-DEBUG_LogAllDOXMLMessage.txt" /&gt;
    &lt;property name="append" value="false" /&gt;
  &lt;/bean&gt;

  &lt;bean id="DEBUG_DOXMLFileReader" class="org.openadaptor.auxil.connector.iostream.reader.FileReadConnector"&gt;
    &lt;description&gt;
      Just for DEBUG: read messages from file (in form output by DEBUG_LogAllDOXMLMessage)
      rather than using preceding JMS reader...
    &lt;/description&gt;
    &lt;property name="filename" value="${somepath}/test/testDOXML.xml" /&gt;
    &lt;property name="dataReader"&gt;
      &lt;bean class="org.openadaptor.auxil.connector.iostream.reader.string.RegexMultiLineReader"&gt;
        &lt;property name="startLineRegex" value="&amp;lt;\?xml version='1.0' encoding='iso-8859-1'\?&amp;gt;" /&gt;
        &lt;property name="endLineRegex" value="&amp;lt;/dataobjectmessage&amp;gt;" /&gt;
        &lt;property name="includeRecordDelimiters" value="true" /&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;


  &lt;bean id="DOXmlConvertor" class="org.openadaptor.legacy.converter.dataobjects.DOXmlToDataObjectConvertor"&gt;
    &lt;description&gt;Convert each DOXML object published over JMS into a legacy OA1.7.2.2 DataObject.&lt;/description&gt;
  &lt;/bean&gt;

  &lt;bean id="DataObjectConvertor" class="org.openadaptor.legacy.converter.dataobjects.DataObjectToXmlConvertor"&gt;
    &lt;description&gt;Convert legacy OA1.7.2.2 DataObject into a plain XML document.&lt;/description&gt;
  &lt;/bean&gt;


  &lt;bean id="XmlExtractFields" class="org.openadaptor.auxil.processor.xml.XsltProcessor"&gt;
    &lt;description&gt;
      Extract just the fields we are interested in from the incoming XML record (which has a nested structure).
      Output them in an XML record which has a flat structure beneath a single root document element.
    &lt;/description&gt;
    &lt;property name="xsltFile" value="${somepath}/config/extractFields.xsl" /&gt;
  &lt;/bean&gt;

  &lt;bean id="XmlToOrderedMapConvertor" class="org.openadaptor.auxil.convertor.xml.XmlToOrderedMapConvertor"&gt;
    &lt;description&gt;The XML record is converted into an ordered map containing just the fields of interest.&lt;/description&gt;
    &lt;property name="expression" value="/extracted_document" /&gt;
    &lt;property name="omitTopLevelElementTag" value="true" /&gt;
  &lt;/bean&gt;


  &lt;bean id="FilterOnMessageTypeContact" class="org.openadaptor.auxil.processor.javascript.JavascriptFilterProcessor"&gt;
    &lt;description&gt;Only pass through messages of type Contact.&lt;/description&gt;
    &lt;property name="script" value="(record.get('messageType') == 'Contact')" /&gt;
    &lt;property name="discardMatches" value="false" /&gt;
  &lt;/bean&gt;</pre></div>
    <p>
      Below is the XSLT transform used by the above example adaptor XML fragment
      (to map an incoming nested DOXML record to a one-level deep XML document record containing
      the extracted content which is ripe for interpreting as a map).
    </p>
    <div class="shell"><pre>&lt;?xml version="1.0"?&gt;
&lt;!--
  $Id: $
  $HeadURL: $
  
  Extracts the fields we are interested in into a flattened XML document.
  
  Uses XPath expressions to extract the elements of interest from the incoming XML record.  
--&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:template match="/"&gt;
    &lt;extracted_document&gt;

      &lt;messageType&gt;&lt;!-- e.g. Contact --&gt;
        &lt;xsl:value-of select="//msgHeader/messageType" /&gt;
      &lt;/messageType&gt;

      &lt;messageVersion&gt;&lt;!-- e.g. 1.2.3 --&gt;
        &lt;xsl:value-of select="//msgHeader/messageVersion" /&gt;
      &lt;/messageVersion&gt;

      &lt;!-- Currently this works because XML document order in JMS message is order of changes, --&gt;
      &lt;!-- so if that stopped being true we would need to xsl:sort the node set on changedAt too. --&gt;
      &lt;changedata&gt;
        &lt;xsl:value-of select="//changeDetails[position()=last()]/changedBy" /&gt;
      &lt;/changedata&gt;


      &lt;sn&gt;
        &lt;xsl:value-of select="//msgContact/familyName" /&gt;
      &lt;/sn&gt;

      &lt;givenname&gt;
        &lt;xsl:value-of select="//msgContact/givenName" /&gt;
      &lt;/givenname&gt;

      &lt;cn&gt;
        &lt;xsl:value-of select="//msgContact/givenName" /&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt; &lt;!-- insert single space --&gt;
        &lt;xsl:value-of select="//msgContact/familyName" /&gt;
      &lt;/cn&gt;
      
      &lt;salutation&gt;&lt;!-- e.g. Mr. --&gt;
        &lt;xsl:value-of select="//msgContact/salutation" /&gt;
      &lt;/salutation&gt;

      &lt;companyname&gt;
        &lt;xsl:value-of select="//msgContact/employer/name" /&gt;
      &lt;/companyname&gt;

      &lt;companyid&gt;
        &lt;xsl:value-of select="//msgContact/employer/identifier/master" /&gt;
      &lt;/companyid&gt;

      &lt;title&gt;&lt;!-- e.g. Partner (want to store as "title" not in "jobposition") --&gt;
        &lt;!-- A JobPosition is required to have a name element; but hasJobPosition is not itself required. --&gt;
        &lt;!-- So this can result in an empty title element. --&gt;
        &lt;xsl:value-of select="//msgContact/hasJobPosition/name" /&gt;
      &lt;/title&gt;

    &lt;/extracted_document&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
    


    <a id="registeringadaptors"></a>
    <h2>How can I register centrally which adaptors are running?</h2>
    <p>
      Concept is that when your adaptors start up you would like them to HTTP(S) POST
      some data to a central server (specific to your organisation!).
    </p>
    <p>
      We have a simple in-house implementation of this server-side
      (with one URL for test and another for production)
      which takes the data posted and writes it to a SQL database.
    </p>
    <p>
      The client-side is part of the OpenAdaptor distribution, and is activated by
      setting one or two extra properties on your Adaptor bean:
    </p>
    <div class="shell"><pre>  &lt;bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor"&gt;
    &lt;description&gt;This is the bean that actually gets run.&lt;/description&gt;
    &lt;property name="messageProcessor" ref="Router" /&gt;
    &lt;property name="registrationUrl" value="${adaptorprop.registration.url}" /&gt;
    &lt;property name="additionalRegistrationProps"&gt;
      &lt;props&gt;
        &lt;prop key="AdaptorVersion"&gt;${adaptorprop.version}"&lt;/prop&gt;
        &lt;prop key="LdapSearchUrl"&gt;${adaptorprop.directory.url.search}&lt;/prop&gt;
        &lt;prop key="LdapUpdateUrl"&gt;${adaptorprop.directory.url.update}&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="running"></a>
    <h2>How can I run an adaptor as an NT Service?</h2>
    <p>There are a number of utilities for running java programs as an NT service. Here are the
    instructions for running one of the tutorial configurations using the Java Service Wrapper
    <a href="http://wrapper.tanukisoftware.org">http://wrapper.tanukisoftware.org</a>.</p>
    
    <ol>
      <li>Download the Java Service Wrapper for windows</li>
      <li>unzip the distribution and copy the following files into the example/bin directory 
        <code>wrapper.exe</code>, <code>wrapper.dll</code>, <code>wrapper.jar</code></li>
      <li>create a configuration file called <code>wrapper.conf</code>, see example below</li>
      <li>test the configuration using <code>wrapper.exe -c wrapper.conf</code></li>
      <li>install as a service using <code>wrapper.exe -i wrapper.conf</code></li>
    </ol>
    
    <h3>openadaptor 3.2.1 example config</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = c:\\installs\\jdk1.4.2\\bin\\java
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.spring.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = c:\\temp\\openadaptor-latest\\example\\tutorial\\step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/openadaptor.jar
  wrapper.java.classpath.3       = ../lib/openadaptor-spring.jar
  wrapper.java.classpath.4       = ../lib/openadaptor-depends.jar
  wrapper.java.classpath.5       = ../lib/3rdparty/jbossall-client.jar

  wrapper.ntservice.name         = openadaptor
  wrapper.ntservice.displayname  = openadaptor example service
  wrapper.ntservice.description  = openadaptor example service
  wrapper.ntservice.starttype    = AUTO_START
  wrapper.ntservice.interactive  = false
      </div></pre>
    
        <h3>post openadaptor 3.2.1 example config (this uses bootstrap spring launcher)</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = c:\\installs\\jdk1.4.2\\bin\\java
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.bootstrap.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = c:\\temp\\openadaptor-latest\\example\\tutorial\\step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/bootstrap.jar

  wrapper.ntservice.name         = openadaptor
  wrapper.ntservice.displayname  = openadaptor example service
  wrapper.ntservice.description  = openadaptor example service
  wrapper.ntservice.starttype    = AUTO_START
  wrapper.ntservice.interactive  = false
      </div></pre>
    <p class="back"><a href="#contents">back to contents</a></p>
        
        
    <a id="daemon"></a>
    <h2>How can I run an adaptor as daemon process?</h2>
    <p>There are a number of utilities for running java programs as daemon. Here are the
    instructions for running one of the tutorial configurations using the Java Service Wrapper
    <a href="http://wrapper.tanukisoftware.org">http://wrapper.tanukisoftware.org</a>.</p>
    
    <ol>
      <li>Download the Java Service Wrapper for your *nix platform</li>
      <li>unzip the distribution and copy the following files into the <code>example/bin</code> directory 
        <code>lib/libwrapper.so</code>, <code>bin/wrapper</code>, <code>lib/wrapper.jar</code></li>
      <li>create a configuration file called <code>wrapper.conf</code>, see example below</li>
      <li>copy the example script <code>src/bin/sh.script.in</code> to <code>wrapper.sh</code></li>
      <li>edit <code>wrapper.sh</code> so that <code>WRAPPER_CONF="./wrapper.conf"</code></li>
      <li>test the configuration using <code>./wrapper.sh console</code></li>
      <li>run as a daemon using <code>./wrapper.sh start</code></li>
      <li>stop daemon using <code>./wrapper.sh stop</code></li>
    </ol>
    
    <h3>openadaptor 3.2.1 example config</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = {your java home}/bin
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.spring.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = {your openadaptor root}/example/tutorial/step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/openadaptor.jar
  wrapper.java.classpath.3       = ../lib/openadaptor-spring.jar
  wrapper.java.classpath.4       = ../lib/openadaptor-depends.jar
  wrapper.java.classpath.5       = ../lib/3rdparty/jbossall-client.jar
      </div></pre>
    
        <h3>post openadaptor 3.2.1 example config (this uses bootstrap spring launcher)</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = {your java home}/bin
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.bootstrap.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = {your openadaptor root}/example/tutorial/step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/bootstrap.jar
      </div></pre>
    <p class="back"><a href="#contents">back to contents</a></p>



    <hr>
    <h1>Getting hold of it:</h1>
    <!--  Getting hold of it: -->
    <!--  Getting hold of it: -->
    <!--  Getting hold of it: -->

    <a id="downloading"></a>
    <h2>How do I Download it?</h2>
    <p>
      <a href="https://openadaptor3.openadaptor.org/servlets/ProjectDocumentList">
        https://openadaptor3.openadaptor.org/servlets/ProjectDocumentList
      </a>
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="examplesbrowsing"></a>
    <h2>Can I browse the Examples/Tutorial online?</h2>
    <p>
      Soon to be added...
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="javadocbrowsing"></a>
    <h2>Can I browse the JavaDoc online?</h2>
    <p>
      Soon to be added...
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="sourcebrowsing"></a>
    <h2>Can I browse the Source Code online?</h2>
    <p>
      Yes.&nbsp;&nbsp;
      <a href="https://openadaptor3.openadaptor.org/source/browse/openadaptor3/trunk/">
        https://openadaptor3.openadaptor.org/source/browse/openadaptor3/trunk/
      </a>
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="eclipsesvn"></a>
    <h2>How do I use Eclipse to checkout the source code? (Subclipse)</h2>
    <p>
      (Please also read <a href="#eclipsetortoiseversions">Which versions of Subclipse and TortoiseSVN work together?</a>)
    </p>
    <p>
      First follow the instructions in <a href="#eclipsesetup">What Eclipse IDE Features should I install?</a>
      to get Spring IDE Feature installed in Eclipse.
    </p>
    <p>
      Then:
    </p>  
    <ol>
      <li>Click Window > Open Perspective > Other > SVN Repository Exploring.
      <li>Click Ok.  Move mouse to the SVN Repository explorer that appears.
      <li>Right click New > Repository Location.
      <li>Enter the URL as <code>https://openadaptor3.openadaptor.org/svn/openadaptor3</code>
      <li>Click Finish.
      <li>Go to the SVN Repository explorer and expand the project from the navigation menu.
      <li>You can see the project contents listed in folders.
      <li>Now select a folder (should be "trunk" or a specific sub-directory of "tags"), 
          right click and select "Checkout as Project".
          <i>Do NOT select the repository as a whole as that will check out a
          full copy of every tagged copy too!</i>
      </li>
    </ol>
    <p>
      You may need to configure Subversion to use your HTTPS proxy server,
      e.g. if you are behind a corporate firewall.
      Because Subclipse uses a separate Subversion library in the background, you will
      need to edit the config for that (typically <code>$HOME/.subversion/servers</code> as described in
      <a href="http://svnbook.red-bean.com/en/1.1/ch07.html#svn-ch-7-sect-1.3.1">Subversion book</a>):
    </p>
    <div class="shell"><pre>[global]
http-proxy-host = myproxy.my.network
http-proxy-port = 8080
http-compression = yes</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
    
    
    <a id="tortoisesvn"></a>
    <h2>Is there a Windows client for checkingout the source code? (TortoiseSVN)</h2>
    <p>
      (Please also read <a href="#eclipsetortoiseversions">Which versions of Subclipse and TortoiseSVN work together?</a>)
    </p>
    <p>
      TortoiseSVN is a Subversion Client for Microsoft Windows which integrates
      with the Windows Shell (Explorer).
    </p>
    <ul>
      <li>http://tortoisesvn.tigris.org/download.html</li>
      <li>http://tortoisesvn.tigris.org/docs.html</li>
    </ul>
    <p>
      Same proxying issues apply to TortoiseSVN as for
      <a href="#eclipsesvn">corporate firewall traversal with Subclipse</a>
      with the caveat that TortoiseSVN also provides a GUI for simple case
      (under Settings > Network) as well as allowing the standard file to
      be used to configure all cases.
      We still recommend configuring in the standard file as then all of your
      local Subversion clients will be using the same configuration.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="eclipsetortoiseversions"></a>
    <h2>Which versions of Subclipse and TortoiseSVN work together?</h2>
    <p>
      The underlying issue is that Subversion itself changed (around 1.2?).
      It maintained compatibility of clients with servers, but it changed the format
      of checked out worktrees which means that different SVN clients cannot always
      be used on the same worktree.
    </p>
    <p>
      We are successfully using the following combination on the same worktree:
    </p>
    <ul>
      <li>Subclipse 1.0.5 (using default Java HL JNI library)</li>
      <li>TortoiseSVN 1.4.3 (contains Subversion 1.4.3)</li>
    </ul>
    <p>
      We tried some of the earlier versions of TortoiseSVN with this version of Subclipse, but
      were unable to use them on the same worktree.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>
    
  </body>
</html>
