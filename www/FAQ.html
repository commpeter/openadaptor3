<html>
  
  <head>
    <title>openadaptor3 FAQ (versions 3.2.1+)</title>
      <STYLE TYPE="text/css">
        .shell    { width: 90%; background-color: #EEEEEE }
        .heading  { width:100%; font-size:14pt; font-weight:bold; border-bottom-style:solid; border-bottom-width:1px; margin-top:40 }
        .back     { text-align: right; font-size:9pt }
      </STYLE>
  </head>
  
  <body>
    <a id="contents"></a>
    <h1>Frequently Asked Questions (versions 3.2.1+)</h1>
    <h3>1. Basics</h3>
    <ol>
      <li><a href="#gettingstarted">Getting started</a></li>
      <li><a href="#typicaldevsteps">Typical developments steps</a></li>
      <li><a href="#classpath">How should I set my classpath?</a></li>
      <li><a href="#xmlconfig">What are in these XML config files?</a></li>
      <li><a href="#payloadneutral">What does "payload neutral" mean for me?</a></li>
      <li><a href="#xmlregexp">How can I transform an XML payload using a regular expression?</a></li>
    </ol>

    <h3>2. Control flow</h3>
    <ol>
      <li><a href="#pipevrouter">Should I use a Pipeline or a Router?</a></li>
      <li><a href="#loggingrecords">How do I write out intermediate processing results or discarded data?</a></li>
      <li><a href="#exceptions">How do I handle Exceptions?</a></li>
      <li><a href="#logging">How does logging work?</a></li>
      <li><a href="#hospital">How do I hospitalise problematic records?</a></li>
      <li><a href="#scriptscontrolflow">Can I use JavaScript control flow inside my JavascriptProcessor scripts?</a></li>
      <li><a href="#filterorcondition">Should I use a Filter or If-Condition-Else components or JavaScript?</a></li>
    </ol>

    <h3>3. Working with XML config files</h3>
    <ol>
      <li><a href="#eclipse">How can Eclipse IDE help me to write my adaptors?</a></li>
      <li><a href="#docgen">How can I generate documentation and pictures for my adaptors?</a></li>
      <li><a href="#variables">How do I set variables from a separate properties file or on the command line?</a></li>
      <li><a href="#singleadaptormultiplefiles">How can I split a single adaptor across multiple XML files?</a></li>
      <li><a href="#multipleadaptorssinglefile">How can I host multiple adaptors in a single XML file?</a></li>
      <li><a href="#runtimeparameters">How do I get JDBCReadConnector to pick up its input parameters at runtime?</a></li>
    </ol>

    <h3>4. Services and Other topics</h3>
    <ol>
      <li><a href="#jmsdoxml">Can I still Subscribe to JMS Messages published in DOXML by an OA1.x Publisher?</a></li>
      <li><a href="#registeringadaptors">How can I register centrally which adaptors are running?</a></li>
      <li><a href="#running">How can I run an adaptor as an NT Service?</a></li>
      <li><a href="#daemon">How can I run an adaptor as daemon process?</a></li>
    </ol>



    <!-- Basics: -->
    <!-- Basics: -->
    <!-- Basics: -->

    <a id="gettingstarted"></a>
    <h2>Getting started</h2>
    <p>We recommend following these steps</p>
    <ol>
      <li>read the <a href="http://www.openadaptor.org/docs/whitepaper.pdf">whitepaper</a></li>
      <li>download the binary distribution from <a href="http://www.openadaptor.org/downloads.html">downloads</a></li>
      <li>unzip</li>
      <li>do the tutorial, contained in the distribution (example/tutorial/index.html)</li>
      <li>read the general README (example/readme.html)</li>
      <li>explore the spring examples, contained in the distribution (example/spring)</li>
    </ol>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="typicaldevsteps"></a>
    <h2>Typical developments steps</h2>
    <p>
      Fundamentally an adaptor is a process that takes data from one place and puts it in another.
      These places can be datastores (e.g. SQL database; filesystem) or entreprise buses (e.g. JMS; MQ).
    </p>
    <p>
      Writing a new adaptor is best done as an incremental process.
      Start at one (or sometimes both) ends and test as you go along.
    </p>
    <ol>
      <li>
        Analyse basic requirements (input; transformation; output(s); logging).
      </li>
      <li>
        Get development environment set up so it can run a trivial example adaptor.
      </li>
      <li>
        Create your new XML config file based on a skeleton file like the
        <a href="#xmlconfig">XML config example</a> below, with an empty Router.
      <li>
        Add components that reads date from your input and writes to a file
        (the file writing component will try to sensibly represent the data).
      </li>
      <li>
        Run your adaptor, and examine the output.
        Have you successfully captured the input data?
      </li>
    </ol>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="classpath"></a>
    <h2>How should I set my classpath?</h2>
    <p>openadaptor lib directory contains the following</p>
    
    <table>
      <tr><td><b>log4j.properties</b></td><td>A sample log4j configuration file</td></tr>
      <tr><td><b>openadaptor.jar</b></td><td>The actual openadaptor code</td></tr>
      <tr><td><b>openadaptor-spring.jar</b></td><td>Helper classes for launching openadaptor processes based on spring configurations</td></tr>
      <tr><td><b>openadaptor-depends.jar</b></td><td>Most of the 3rdparty jars, re-jarred as a single jar for convenience</td></tr>
      <tr><td><b>3rdparty</b></td><td>The 3rd party jars</td></tr>
    </table>
    
    <p>Your classpath needs to contain <b>openadaptor.jar</b>. If you are using our spring helper
    classes to run an adaptor / application then you will need <b>openadaptor-spring.jar</b>. You will also
    need a subset of the 3rdparty jars upon which openadaptor relies, the easist approach is to include
    <b>openadaptor-depends.jar</b>. So your classpath would be something like this...</p>
    
    windows
    <div class="shell"><pre>  set CLASSPATH=lib;lib/openadaptor.jar;lib/openadaptor-spring.jar;lib/openadaptor-depends.jar</pre></div>
    
    *nix
    <div class="shell"><pre>  CLASSPATH=lib:lib/openadaptor.jar:lib/openadaptor-spring.jar:lib/openadaptor-depends.jar
  export CLASSPATH</pre></div>
    
    <p>example/bin contains a windows bat script and a bash profile that sets your CLASSPATH like this.
      However you may decide to include just the 3rdparty jars that you need which is why we include the 3rdparty directory.</p>
    
    <p>post release 3.2.1, openadaptor comes with an additonal jar called <b>bootstrap.jar</b>. This contains
    alternative helper classes that will bootstrap the classpath based on the location of the bootstrap.jar.
    All you need in your classpath is bootstrap.jar. You can dump out the programs that can be run
    from this bootstrap.jar like this</p>

    <div class="shell"><pre>  java -jar bootstrap.jar</pre></div>
    
    <p>This should print something like the following...</p>
    
    <div class="shell"><pre>  This jar contains the following programs :
    org.openadaptor.bootstrap.FileSystemExceptionManager
    org.openadaptor.bootstrap.JDBCExceptionManager
    org.openadaptor.bootstrap.SpringAdaptor
    org.openadaptor.bootstrap.SpringApplication
  When you run these they will bootstrap the classpath based on the location of this jar
  use -Dopenadaptor.lib=... to provide an additional location to search for classpath resources</pre></div>
    
    <p>These bootstrapping programs will automatically construct the classpath based on the location
    of the bootstrap.jar. The classpath will contain all the jars, zip and subdirectories. You can specify an additional directory
    to search using the openadaptor.lib system property. <b>patch.jar</b> will always be placed at the
    front of the classpath, it will load the contents of 3rdparty rather than openadaptor-depends.jar,
    openadaptor-stub.jar will always be at the end of the classpath.</p>
    
    <p>example 1:</p>
    <div class="shell"><pre>   java -classpath lib\bootstrap.jar org.openadaptor.bootstrap.SpringAdaptor -config foo.xml</pre></div>
    
    <p>example 2:</p>
    <div class="shell"><pre>  SET CLASSPATH=lib\bootstrap.jar
  java org.openadaptor.bootstrap.SpringAdaptor -config foo.xml</pre></div>
    
    <p>example 3:</p>
    <div class="shell"><pre>  SET CLASSPATH=lib\bootstrap.jar
  java -Dopenadaptor.lib=c:\tibco\tibrv\lib org.openadaptor.bootstrap.SpringAdaptor -config tibco.xml</pre></div>
    
    <p>
      <b>Note: The command line syntax is under review following release of version 3.2.1,
      and so the syntax might change in the next release.</b>
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>
    

    <a id="xmlconfig"></a>
    <h2>What are in these XML config files?</h2>
    <p>
      The XML files are Spring 2.0 configuration files.
      The OpenAdaptor 3.x components have been written as Spring "beans".
    </p>
    <p>
      Please make use of the Spring &lt;description&gt; element as illustrated here.
      This allows you to insert descriptive comments in your code for beans and for each of their properties.
      Our <a href="#docgen">documentation and picture generation</a> exploits the presence of the descriptions.
    </p>
    <p>
      Here is a boilerplate example, which includes a non-trivial routing table:
    </p>
    <div class="shell"><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--
  Documentation generation currently relies on having a HeadURL svn:property
  (due to limitation of XSLT 1.1 in that it does not know name/path of file it is processing)
  which must be between the "xml version" first line and the "beans" element
  (which in turn must refer to the Spring 2.0 XML Schema Description).
  
  $Id: $
  $HeadURL: $
--&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd"&gt;

  &lt;description&gt;&lt;![CDATA[
  Minimal example.
  
  Just shows XML fragments that should always be there (in some form or other).
  
  The XML files are Spring 2.0 configuration files.
  The OpenAdaptor 3.x components have been written as Spring "beans".
  
  Read the rest of the FAQ to learn more about working with these XML files.
  ]]&gt;&lt;/description&gt;


  &lt;bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor"&gt;
    &lt;description&gt;
      This is the bean that actually gets run.
      It is possible to have several in one XML config file, and then to tell adaptor which one to run on command line.
      We would recommend having exactly one of these per XML config file.
    &lt;/description&gt;
    &lt;property name="messageProcessor" ref="Router" /&gt;
  &lt;/bean&gt;


  &lt;bean id="Router" class="org.openadaptor.core.router.Router"&gt;
    &lt;description&gt;
      The adaptor delegates it's message processing to a router.
      The router uses this mapping to define the "processing pipeline".

      Main control flow is:
        Reader -&gt; Filter -&gt; Modifier |-&gt; DatabaseWriter
                                     |-&gt; FileLogger

      However, anything that is discarded by the Filter will then go:
        DiscardedFormatter -&gt; DiscardedWriter

      And ProcessingExceptions thrown by Filter (and subsequent nodes) are sent to FailedParsingLogger,
      except those thrown by DatabaseWriter which are sent to FailedWritesLogger.
    &lt;/description&gt;
    &lt;property name="processMap"&gt;
      &lt;map&gt;
        &lt;entry key-ref="Reader" value-ref="Filter" /&gt;

        &lt;entry key-ref="Filter" value-ref="Modifier" /&gt;

        &lt;entry key-ref="Modifier"&gt;
          &lt;list&gt;
            &lt;ref bean="DatabaseWriter" /&gt;
            &lt;ref bean="FileLogger" /&gt;
          &lt;/list&gt;
        &lt;/entry&gt;
        
        &lt;!--  Other subsidiary pipelines: --&gt;
        &lt;entry key-ref="DiscardedFormatter" value-ref="DiscardedWriter" /&gt;        
      &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name="discardMap"&gt;
      &lt;map&gt;
        &lt;entry key-ref="Filter" value-ref="DiscardedFormatter" /&gt;
      &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name="exceptionMap"&gt;
      &lt;description&gt;Catch input parsing problems and bad writes here...&lt;/description&gt;
      &lt;map&gt;
        &lt;entry key-ref="Filter"&gt;
          &lt;map&gt;
            &lt;entry key="org.openadaptor.core.exception.ProcessingException" value-ref="FailedParsingLogger" /&gt;
          &lt;/map&gt;
        &lt;/entry&gt;
        &lt;entry key-ref="DatabaseWriter"&gt;
          &lt;map&gt;
            &lt;entry key="org.openadaptor.core.exception.ProcessingException" value-ref="FailedWritesLogger" /&gt;
          &lt;/map&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  &lt!-- Definitions of all of the beans referred to in the routing table come here. --&gt;
&lt;/beans&gt;</pre></div>
    <p>
      You can see an XML config fragment below for <a href="#jmsdoxml">reading legacy JMS DOXML</a>
      which shows a routing table and almost all of the beans referred to by it.
      Note the way that we use <code>id</code> attribute to name and refer to beans:
      this is the way that Spring works (and XML states that <code>id</code> is unique within file).
    </p>
    <p>
      Spring also allows <code>name</code> attribute to be used to provide aliases, but
      we would advocate avoiding using this unless absolutely necessary (as you will get
      much poorer support from XML editing tools and XML Validation will not be able to
      spot some obvious bugs on your behalf).
    </p>
    <p>
      Some bean ids will not be mentioned in the Router, e.g.
    </p>
    <ul>
      <li>Helper bean nested inside a top-level bean.</li>
      <li>Helper bean at top-level and referred to directly/indirectly by a bean referred to in the Router.</li>
      <li>Beans whose presence simply has the side effect of configuring adaptor services.</li>
    </ul>
    <p>
      Examples of the last category are
      <a href="#variables">Spring's PropertyPlaceholderConfigurer bean</a>
      and
      <a href="#registeringadaptors">OpenAdaptor's central registration config</a>.
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="payloadneutral"></a>
    <h2>What does "payload neutral" mean for me?</h2>
    <p>
      In OpenAdaptor version 1.x all data records were passed around as a custom Java type called DataObject.
      Incoming data had to be a DataObject before it could be processed.
    </p>
    <p>
      In OpenAdaptor version 3.0+ we have thrown away that restriction, and the data records passed
      around simply need to be of standard Java type Object.
    </p>
    <p>
      So you can read data in from one place and write it out to another, without ever needing to
      map it to a different representation.
      This avoids lossy (non-idempotent) or pointless (excess processing overhead) conversions.
    </p>
    <p>
      A good example of this is reading an XML record from one place and writing an XML record
      out to another place, perhaps having modified it using an XSLT transform or one of our
      other components that can work with XML payloads, and treating it as an XML document throughout.
    </p>
    <p>
      An objective of OpenAdaptor is to promote reuse of standard components, and so we had to
      settle on some standard payload formats to target our components at.  (Note this is just a
      necessary restriction as to what individual components can handle: the framework itself is payload neutral).
    </p>
    <p>
      We support a variety of payload formats, but with a special emphasis on Maps and XML.
      (We are actively working on further improving/harmonising this area for post 3.2.1 releases.)
    </p>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="xmlregexp"></a>
    <h2>How can I transform an XML payload using a regular expression?</h2>
    <p>
      The OpenAdaptor XSLT component will meet most of your transformation needs when
      reading XML and writing XML out.
    </p>
    <p>
      Whilst XSLT 1.1 has substring methods it lacks regular expression support.
      So you would choose to use one of our standard scripting components to
      modify/filter based on a regular expression.
    </p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <!-- Control flow: -->
    <!-- Control flow: -->
    <!-- Control flow: -->

    <a id="pipevrouter"></a>
    <h2>Should I use a Pipeline or a Router?</h2>
    <p>
      You must use a Router if you have multiple routes through an adaptor.
    </p>
    <p>
      The Pipeline provides a terser syntactic sugar for adaptors with a single route.
    </p>
    <p>
      So in general we would recommend that you start with a Router for production strength adaptors.
    <p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="loggingrecords"></a>
    <h2>How do I write out intermediate processing results or discarded data?</h2>
    <p>
      Use a Router rather than a Pipeline.
      In the Router you can say where all data goes to regardless of whether it is successfully processed
      (unlike in OpenAdaptor 1.x where you had to write a second inverted-logic filter to catch discarded data).
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="exceptions"></a>
    <h2>How do I handle Exceptions?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="logging"></a>
    <h2>How does logging work?</h2>
    <p>We use Apache Commons logging abstraction in our classes, and typically behind that we use Log4j at runtime.</p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>


    

    <a id="hospital"></a>
    <h2>How do I hospitalise problematic records?</h2>
    <p>
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="scriptscontrolflow"></a>
    <h2>Can I use JavaScript control flow inside my JavascriptProcessor scripts?</h2>
    <p></p>
    <div class="shell"><pre>  &lt;bean id="FilterOnMessageTypeContact" class="org.openadaptor.auxil.processor.javascript.JavascriptFilterProcessor"&gt;
    &lt;description&gt;Only pass through messages of type Contact.&lt;/description&gt;
    &lt;property name="script" value="
        (record.get('messageType') == 'Contact')
    "/&gt;
    &lt;property name="discardMatches" value="false" /&gt;
  &lt;/bean&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="filterorcondition"></a>
    <h2>Should I use a Filter or If-Condition-Else components or JavaScript?</h2>
    <p>
      It depends: use the one that is most suitable.
      It is reasonable to combine them.
      You should be guided by what makes your intent clearest (both in the XML config and
      in the <a href="#docgen">generated node map images</a>).
    </p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <!-- Working with XML config files: -->
    <!-- Working with XML config files: -->
    <!-- Working with XML config files: -->

    <a id="eclipse"></a>
    <h2>How can Eclipse IDE help me to write my adaptors?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>


    
    <a id="docgen"></a>
    <h2>How can I generate documentation and pictures for my adaptors?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="variables"></a>
    <h2>How do I set variables from a separate properties file or on the command line?</h2>
    <p>
      You can define whichever properties you like and you have options in configuring the
      <a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-factory-placeholderconfigurer">PropertyPlaceholderConfigurer</a>.
    </p>
    <div class="shell"><pre>  &lt;bean id="SystemPropertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="ignoreResourceNotFound" value="true" /&gt;
    &lt;property name="systemPropertiesMode"&gt;
      &lt;bean id="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
    &lt;/property&gt;
    &lt;property name="locations"&gt;
      &lt;description&gt;
        Properties set by a file in list below are supposedly overridden by settings in a file later in list below.
      &lt;/description&gt;
      &lt;list&gt;
        &lt;value&gt;classpath:general.properties&lt;/value&gt;
        &lt;value&gt;classpath:specific.properties&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</pre></div>
    <p>
      The above PropertyPlaceholderConfigurer configuration says to pick up these values
      from the two specified Java Properties files, and to ovveride these settings with
      values found in the Java SystemProperties (typically set with <code>-Dname=value</code>
      command line options).
    </p>
    <p>
      You then access the properties as <code>${myPropertyName}</code> within your XML config file.
    </p>
    <p>
      See <a href="#runtimeparameters">runtime parameters</a> example below.
    </p>  
    <p>
      This parameterisation technique is also very valuable as it allows you to deploy
      the same XML config file with different Java Properties files in Development/Test/Production.
      That also then allows you to then publish your XML config file without fear of exposing passwords
      as these will be in the environment specific Java Properties files.
    </p>
    <p>
      <b>Note: We are planning to make this easier in the release after 3.2.1 (e.g. automatic detection of
      <code>-D</code> properties causing a default PropertyPlaceholderConfigurer to be created in memory
      if there is no user specified one).</b>
    <p>  
    <p class="back"><a href="#contents">back to contents</a></p>

    

    <a id="singleadaptormultiplefiles"></a>
    <h2>How can I split a single adaptor across multiple XML files?</h2>
    <p>
      These are Spring XML config files, so you can have multiple files that are combined together in a single adaptor.
    </p>
    <p>
      Spring defines that each of these XML files must be a proper Spring XML file (including <code>&lt;beans&gt;</code> top-level element).
    </p>
    <p> 
      There are two different ways that you can combine them:
    </p>
    <ol>
      <li>
        Supply multiple XML filenames as SpringAdaptor command line arguments <b>(recommended)</b>.
      </li>
      <li> 
        Use the <code>&lt;import resource="someFile.xml"/&gt;</code> element (must be first element(s)
        after <code>&lt;beans&gt;</code> tag of importing XML file) and then just supply the importing
        XML filename on SpringAdaptor command line.
      </li>
    </ol>
    <p>
      Your different files will each contain multiple <code>&lt;bean&gt;</code> elements.
      Each &lt;bean&gt; element should have an <code>id</code> attribute
      (e.g. <code>&lt;bean id="myBean" class="org.openadaptor.Something"/&gt;</code>).
      Then rather than having an in-line bean definition you can have a <code>ref</code>
      (or <code>bean-ref</code>) attribute whose value is the <code>id</code>
      (e.g. <code>&lt;property name="someProperty" ref="myBean"/&gt;</code>).
      You should see how this can be used to share a bean definition between files, and thus across adaptors.
      And so you can achieve what you want provided that you can express it at the bean level.
    </p>
    <!-- <div class="shell"><pre>  </pre></div> -->
    <p class="back"><a href="#contents">back to contents</a></p>
    


    <a id="multipleadaptorssinglefile"></a>
    <h2>How can I host multiple adaptors in a single XML file?</h2>
    <p></p>
    <div class="shell"><pre>  </pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
    


    <a id="runtimeparameters"></a>
    <h2>How do I get JDBCReadConnector to pick up its input parameters at runtime?</h2>
    <p>
      You can have a JDBCReadConnector, which executes a dynamic query,
      i.e. a query which reads input parameters at runtime via command line or property file.
    </p>
    <div class="shell"><pre>  &lt;bean id="Reader" class="org.openadaptor.auxil.jdbc.reader.JDBCReadConnector"&gt;
    &lt;property name="jdbcConnection" ref="JdbcConnection"/&gt;
    &lt;property name="sql" value="Select * from dbo.mydata where valid_from &gt; ${start} And valid_from &lt; ${end}"/&gt;
  &lt;/bean&gt;</pre></div>
    <p>
      You then configure a PropertyPlaceholderConfigurer and pass in data as defined in
      <a href="#variables">variables setting section</a> above.      
    </p>
    <p>
      So then you could start your adaptor as follows:
    </p>
    <div class="shell"><pre>  java -Dstart=whatever -Dend=whatever org.openadaptor... etc</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
 


    <!-- Services and Other topics: -->
    <!-- Services and Other topics: -->
    <!-- Services and Other topics: -->

    <a id="jmsdoxml"></a>
    <h2>Can I still Subscribe to JMS Messages published in DOXML by an OA1.x Publisher?</h2>
    <p>Yes :-)</p>
    <p>
      We have provided a set of components to support this (they offer a useful level of backwards compatability).
      We have tested these components using OpenAdaptor 1.7.2.2,
      and would strongly recommend that you upgrade your publisher to this level first
      (especially if you are using types other than Strings in your DOXML).
    </p>
    <p>The basic dataflow is:</p>
    <ol>
      <li>
        "payload neutral" records are read off the wire by standard OpenAdaptor3 components.
      </li>
      <li>
        Then parsed as DOXML and the body (only) of the message is written out as plain XML by
        a legacy openadaptor1.x component (from an OpenAdaptor 1.x jar on the classpath).
      </li>
      <li>
        Then treated as a vanilla XML payload by standard OpenAdaptor3 components
        <a href="#payloadneutral">(see "payload neutral")</a>
      </li>
    </ol>
    <p>
      <b>::TODO:: Need to describe classpath...</b>
    </p>
    <div class="shell"><pre>  &lt;bean id="Router" class="org.openadaptor.core.router.Router"&gt;
    &lt;description&gt;
      The adaptor delegates it's message processing to a router.
      The router uses this mapping to define the "processing pipeline".

      This routing is deliberately incomplete (just describes reading in the data and parsing it).
      Needs to also describe writing it out too.
      
      When testing the rest of the adaptor (during development or regression) it is very useful
      to be able to re-inject JMS DOXML messages that were previously captured.
      That is what the "DEBUG_" beans are used for.
      You can fan-out the records from the wire so that they are both captured and processed.
      And later you can decide that rather than reading records from the JMS service, you want
      to replay previously captured JMS DOXML/XML messages from file.
      The captured messages also serve as a log of the data sent over the wire, which is very
      useful when you are trying to write parsing/processing components such as XSLT transforms.
    &lt;/description&gt;
    &lt;property name="processMap"&gt;
      &lt;map&gt;
        &lt;!-- Read XML from JMS:--&gt;
        &lt;entry key-ref="MyReader"&gt;
          &lt;list&gt;
            &lt;!-- &lt;ref bean="DEBUG_LogAllDOXMLMessage" /&gt; --&gt;  &lt;!-- in Production MUST comment out this DOXML DEBUG logging line!--&gt;
            &lt;ref bean="DOXmlConvertor" /&gt;
          &lt;/list&gt;
        &lt;/entry&gt;
        
        &lt;!-- Just for DEBUG: read DOXML from DEBUG test file instead of reading from JMS: --&gt;
        &lt;!-- &lt;entry key-ref="DEBUG_DOXMLFileReader" value-ref="DOXmlConvertor" /&gt; --&gt;

        &lt;entry key-ref="DOXmlConvertor" value-ref="DataObjectConvertor" /&gt;

        &lt;entry key-ref="DataObjectConvertor" value-ref="XmlExtractFields" /&gt;

        &lt;entry key-ref="XmlExtractFields" value-ref="XmlToOrderedMapConvertor" /&gt;

        &lt;entry key-ref="XmlToOrderedMapConvertor" value-ref="FilterOnMessageTypeContact" /&gt;

        &lt;!-- More config required: Needs to do any further processing and then write the results somewhere... --&gt;
      &lt;/map&gt;
    &lt;/property&gt;

    &lt;property name="exceptionMap"&gt;
      &lt;description&gt;Catch input parsing problems here...&lt;/description&gt;
      &lt;map&gt;
        &lt;entry key-ref="DOXmlConvertor"&gt;
          &lt;map&gt;
            &lt;entry key="org.openadaptor.core.exception.ProcessingException" value-ref="FailedReadsOutpoint" /&gt;
          &lt;/map&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="MyJndiConnection" class="org.openadaptor.auxil.connector.jndi.JNDIConnection"&gt;
    &lt;property name="initialContextFactory" value="com.sun.jndi.ldap.LdapCtxFactory" /&gt;
    &lt;property name="providerUrl" value="${adaptorprop.jms.jndiconnection.providerurl}" /&gt;
    &lt;property name="securityPrincipal"   value="${adaptorprop.jms.jmsservice.username}" /&gt;
    &lt;property name="securityCredentials" value="${adaptorprop.jms.jmsservice.password}" /&gt;
  &lt;/bean&gt;

  &lt;bean id="MyJmsConnection" class="org.openadaptor.auxil.connector.jms.JMSConnection"&gt;
    &lt;description&gt;JMS connection for queue we wish to subscribe to.&lt;/description&gt;
    &lt;property name="jndiConnection" ref="MyJndiConnection" /&gt;
    &lt;property name="connectionFactoryName" value="${adaptorprop.jms.jmsconnection.connectionfactoryname}" /&gt;
    &lt;property name="username" value="${adaptorprop.jms.jmsconnection.username}" /&gt;
    &lt;property name="password" value="${adaptorprop.jms.jmsconnection.password}" /&gt;
  &lt;/bean&gt;


  &lt;bean id="MyReader" class="org.openadaptor.auxil.connector.jms.JMSReadConnector"&gt;
    &lt;description&gt;Reader that polls a JMS queue.&lt;/description&gt;
    &lt;property name="destinationName" value="cn=someTopic" /&gt;
    &lt;property name="jmsConnection" ref="MyJmsConnection" /&gt;
    &lt;property name="transacted" value="true" /&gt;
    &lt;property name="durable" value="${adaptorprop.jms.jmsreadconnector.durable}" /&gt;
    &lt;property name="durableSubscriptionName" value="${adaptorprop.jms.jmsreadconnector.durablesubscriptionname}" /&gt;
  &lt;/bean&gt;


  &lt;bean id="DEBUG_LogAllDOXMLMessage" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector"&gt;
    &lt;description&gt;Just for writing out data to use for DEBUG (raw DOXML).&lt;/description&gt;
    &lt;property name="filename" value="${somePath}/logs/${adaptorprop.timestamp}-0-DEBUG_LogAllDOXMLMessage.txt" /&gt;
    &lt;property name="append" value="false" /&gt;
  &lt;/bean&gt;

  &lt;bean id="DEBUG_DOXMLFileReader" class="org.openadaptor.auxil.connector.iostream.reader.FileReadConnector"&gt;
    &lt;description&gt;
      Just for DEBUG: read messages from file (in form output by DEBUG_LogAllDOXMLMessage)
      rather than using preceding JMS reader...
    &lt;/description&gt;
    &lt;property name="filename" value="${somepath}/test/testDOXML.xml" /&gt;
    &lt;property name="dataReader"&gt;
      &lt;bean class="org.openadaptor.auxil.connector.iostream.reader.string.RegexMultiLineReader"&gt;
        &lt;property name="startLineRegex" value="&amp;lt;\?xml version='1.0' encoding='iso-8859-1'\?&amp;gt;" /&gt;
        &lt;property name="endLineRegex" value="&amp;lt;/dataobjectmessage&amp;gt;" /&gt;
        &lt;property name="includeRecordDelimiters" value="true" /&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;


  &lt;bean id="DOXmlConvertor" class="org.openadaptor.legacy.converter.dataobjects.DOXmlToDataObjectConvertor"&gt;
    &lt;description&gt;Convert each DOXML object published over JMS into a legacy OA1.7.2.2 DataObject.&lt;/description&gt;
  &lt;/bean&gt;

  &lt;bean id="DataObjectConvertor" class="org.openadaptor.legacy.converter.dataobjects.DataObjectToXmlConvertor"&gt;
    &lt;description&gt;Convert legacy OA1.7.2.2 DataObject into a plain XML document.&lt;/description&gt;
  &lt;/bean&gt;


  &lt;bean id="XmlExtractFields" class="org.openadaptor.auxil.processor.xml.XsltProcessor"&gt;
    &lt;description&gt;
      Extract just the fields we are interested in from the incoming XML record (which has a nested structure).
      Output them in an XML record which has a flat structure beneath a single root document element.
    &lt;/description&gt;
    &lt;property name="xsltFile" value="${somepath}/config/extractFields.xsl" /&gt;
  &lt;/bean&gt;

  &lt;bean id="XmlToOrderedMapConvertor" class="org.openadaptor.auxil.convertor.xml.XmlToOrderedMapConvertor"&gt;
    &lt;description&gt;The XML record is converted into an ordered map containing just the fields of interest.&lt;/description&gt;
    &lt;property name="expression" value="/extracted_document" /&gt;
    &lt;property name="omitTopLevelElementTag" value="true" /&gt;
  &lt;/bean&gt;


  &lt;bean id="FilterOnMessageTypeContact" class="org.openadaptor.auxil.processor.javascript.JavascriptFilterProcessor"&gt;
    &lt;description&gt;Only pass through messages of type Contact.&lt;/description&gt;
    &lt;property name="script" value="(record.get('messageType') == 'Contact')" /&gt;
    &lt;property name="discardMatches" value="false" /&gt;
  &lt;/bean&gt;</pre></div>
    <p>
      Below is the XSLT transform used by the above example adaptor XML fragment
      (to map an incoming nested DOXML record to a one-level deep XML document record containing
      the extracted content which is ripe for interpreting as a map).
    </p>
    <div class="shell"><pre>&lt;?xml version="1.0"?&gt;
&lt;!--
  $Id: $
  $HeadURL: $
  
  Extracts the fields we are interested in into a flattened XML document.
  
  Uses XPath expressions to extract the elements of interest from the incoming XML record.  
--&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:template match="/"&gt;
    &lt;extracted_document&gt;

      &lt;messageType&gt;&lt;!-- e.g. Contact --&gt;
        &lt;xsl:value-of select="//msgHeader/messageType" /&gt;
      &lt;/messageType&gt;

      &lt;messageVersion&gt;&lt;!-- e.g. 1.2.3 --&gt;
        &lt;xsl:value-of select="//msgHeader/messageVersion" /&gt;
      &lt;/messageVersion&gt;

      &lt;!-- Currently this works because XML document order in JMS message is order of changes, --&gt;
      &lt;!-- so if that stopped being true we would need to xsl:sort the node set on changedAt too. --&gt;
      &lt;changedata&gt;
        &lt;xsl:value-of select="//changeDetails[position()=last()]/changedBy" /&gt;
      &lt;/changedata&gt;


      &lt;sn&gt;
        &lt;xsl:value-of select="//msgContact/familyName" /&gt;
      &lt;/sn&gt;

      &lt;givenname&gt;
        &lt;xsl:value-of select="//msgContact/givenName" /&gt;
      &lt;/givenname&gt;

      &lt;cn&gt;
        &lt;xsl:value-of select="//msgContact/givenName" /&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt; &lt;!-- insert single space --&gt;
        &lt;xsl:value-of select="//msgContact/familyName" /&gt;
      &lt;/cn&gt;
      
      &lt;salutation&gt;&lt;!-- e.g. Mr. --&gt;
        &lt;xsl:value-of select="//msgContact/salutation" /&gt;
      &lt;/salutation&gt;

      &lt;companyname&gt;
        &lt;xsl:value-of select="//msgContact/employer/name" /&gt;
      &lt;/companyname&gt;

      &lt;companyid&gt;
        &lt;xsl:value-of select="//msgContact/employer/identifier/master" /&gt;
      &lt;/companyid&gt;

      &lt;title&gt;&lt;!-- e.g. Partner (want to store as "title" not in "jobposition") --&gt;
        &lt;!-- A JobPosition is required to have a name element; but hasJobPosition is not itself required. --&gt;
        &lt;!-- So this can result in an empty title element. --&gt;
        &lt;xsl:value-of select="//msgContact/hasJobPosition/name" /&gt;
      &lt;/title&gt;

    &lt;/extracted_document&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>
    


    <a id="registeringadaptors"></a>
    <h2>How can I register centrally which adaptors are running?</h2>
    <p>
      Concept is that when your adaptors start up you would like them to HTTP(S) POST
      some data to a central server (specific to your organisation!).
    </p>
    <p>
      We have a simple in-house implementation of this server-side
      (with one URL for test and another for production)
      which takes the data posted and writes it to a SQL database.
    </p>
    <p>
      The client-side is part of the OpenAdaptor distribution, and is activated by
      setting one or two extra properties on your Adaptor bean:
    </p>
    <div class="shell"><pre>  &lt;bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor"&gt;
    &lt;description&gt;This is the bean that actually gets run.&lt;/description&gt;
    &lt;property name="messageProcessor" ref="Router" /&gt;
    &lt;property name="registrationUrl" value="${adaptorprop.registration.url}" /&gt;
    &lt;property name="additionalRegistrationProps"&gt;
      &lt;props&gt;
        &lt;prop key="AdaptorVersion"&gt;${adaptorprop.version}"&lt;/prop&gt;
        &lt;prop key="LdapSearchUrl"&gt;${adaptorprop.directory.url.search}&lt;/prop&gt;
        &lt;prop key="LdapUpdateUrl"&gt;${adaptorprop.directory.url.update}&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;</pre></div>
    <p class="back"><a href="#contents">back to contents</a></p>



    <a id="running"></a>
    <h2>How can I run an adaptor as an NT Service?</h2>
    <p>There are a number of utilities for running java programs as an NT service. Here are the
    instructions for running one of the tutorial configurations using the Java Service Wrapper
    <a href="http://wrapper.tanukisoftware.org">http://wrapper.tanukisoftware.org</a>.</p>
    
    <ol>
      <li>Download the Java Service Wrapper for windows</li>
      <li>unzip the distribution and copy the following files into the example/bin directory 
        <code>wrapper.exe</code>, <code>wrapper.dll</code>, <code>wrapper.jar</code></li>
      <li>create a configuration file called <code>wrapper.conf</code>, see example below</li>
      <li>test the configuration using <code>wrapper.exe -c wrapper.conf</code></li>
      <li>install as a service using <code>wrapper.exe -i wrapper.conf</code></li>
    </ol>
    
    <h3>openadaptor 3.2.1 example config</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = c:\\installs\\jdk1.4.2\\bin\\java
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.spring.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = c:\\temp\\openadaptor-latest\\example\\tutorial\\step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/openadaptor.jar
  wrapper.java.classpath.3       = ../lib/openadaptor-spring.jar
  wrapper.java.classpath.4       = ../lib/openadaptor-depends.jar
  wrapper.java.classpath.5       = ../lib/3rdparty/jbossall-client.jar

  wrapper.ntservice.name         = openadaptor
  wrapper.ntservice.displayname  = openadaptor example service
  wrapper.ntservice.description  = openadaptor example service
  wrapper.ntservice.starttype    = AUTO_START
  wrapper.ntservice.interactive  = false
      </div></pre>
    
        <h3>post openadaptor 3.2.1 example config (this uses bootstrap spring launcher)</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = c:\\installs\\jdk1.4.2\\bin\\java
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.bootstrap.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = c:\\temp\\openadaptor-latest\\example\\tutorial\\step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/bootstrap.jar

  wrapper.ntservice.name         = openadaptor
  wrapper.ntservice.displayname  = openadaptor example service
  wrapper.ntservice.description  = openadaptor example service
  wrapper.ntservice.starttype    = AUTO_START
  wrapper.ntservice.interactive  = false
      </div></pre>
    <p class="back"><a href="#contents">back to contents</a></p>
        
        
    <a id="daemon"></a>
    <h2>How can I run an adaptor as daemon process?</h2>
    <p>There are a number of utilities for running java programs as daemon. Here are the
    instructions for running one of the tutorial configurations using the Java Service Wrapper
    <a href="http://wrapper.tanukisoftware.org">http://wrapper.tanukisoftware.org</a>.</p>
    
    <ol>
      <li>Download the Java Service Wrapper for your *nix platform</li>
      <li>unzip the distribution and copy the following files into the <code>example/bin</code> directory 
        <code>lib/libwrapper.so</code>, <code>bin/wrapper</code>, <code>lib/wrapper.jar</code></li>
      <li>create a configuration file called <code>wrapper.conf</code>, see example below</li>
      <li>copy the example script <code>src/bin/sh.script.in</code> to <code>wrapper.sh</code></li>
      <li>edit <code>wrapper.sh</code> so that <code>WRAPPER_CONF="./wrapper.conf"</code></li>
      <li>test the configuration using <code>./wrapper.sh console</code></li>
      <li>run as a daemon using <code>./wrapper.sh start</code></li>
      <li>stop daemon using <code>./wrapper.sh stop</code></li>
    </ol>
    
    <h3>openadaptor 3.2.1 example config</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = {your java home}/bin
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.spring.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = {your openadaptor root}/example/tutorial/step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/openadaptor.jar
  wrapper.java.classpath.3       = ../lib/openadaptor-spring.jar
  wrapper.java.classpath.4       = ../lib/openadaptor-depends.jar
  wrapper.java.classpath.5       = ../lib/3rdparty/jbossall-client.jar
      </div></pre>
    
        <h3>post openadaptor 3.2.1 example config (this uses bootstrap spring launcher)</h3>
    
      <div class="shell"><pre>
  wrapper.java.command           = {your java home}/bin
  wrapper.java.mainclass         = org.tanukisoftware.wrapper.WrapperSimpleApp

  wrapper.app.parameter.1        = org.openadaptor.bootstrap.SpringAdaptor
  wrapper.app.parameter.2        = -config
  wrapper.app.parameter.3        = {your openadaptor root}/example/tutorial/step04.xml

  wrapper.java.classpath.1       = wrapper.jar
  wrapper.java.classpath.2       = ../lib/bootstrap.jar
      </div></pre>
    <p class="back"><a href="#contents">back to contents</a></p>
  </body>
</html>
