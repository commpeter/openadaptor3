<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=Cp1252"/>
<STYLE TYPE="text/css">
  .shell { width: 90%; background-color: EEEEEE }
</STYLE>
<title>openadaptor tutorial</title>
</head>
<body>
<h1>Tutorial</h1>
<p>This tutorial assumes that you have already managed to install openadaptor, set your
Java CLASSPATH and verify that you can sun the simple adaptor. If not then please refer 
to the instructions in <a href="../readme.html">example/readme.html</a>.</p>

<p>It is strongly recommended that you read the openadaptor whitepaper, before attempting
this tutorial.</p>

<p>In this tutorial you will run a series of adaptors that illustrate openadaptor, the
instrcutions show you how to run these from the command prompt / shell. The examples
are simplistic in order make them easy to run and experiment with. All of the adaptors
are expressed as spring framework configuration files. 
The later examples use JMS and you will need to install and run a default jboss 
implementation for these to work, other examples illustrate writing data to a database,
for simplicity we use hypersonic db, which you will need to runup.</p>

<a name="contents"/>
<h2>Contents</h2>
<li><a href="#initial">Set Up</a></li>
<li><a href="#step1">Step 1</a></li>
<li><a href="#step2">Step 2</a></li>
<li><a href="#step3">Step 3</a></li>
<li><a href="#step4">Step 4</a></li>
<li><a href="#step5">Step 5</a></li>
<li><a href="#step6">Step 6</a></li>
<li><a href="#step7">Step 7</a></li>
<li><a href="#step8">Step 8</a></li>
<li><a href="#step9">Step 9</a></li>
<li><a href="#step10">Step 10</a></li>

<a name="initial"/>
<h2>Set Up</h2>
<p>launch a command prompt / shell and follow these these instructions</p>
<h4>Windows</h4>
<div class="shell"><pre>
  cd example\tutorial
  set CLASSPATH=.;..\..\lib\openadaptor.jar;..\..\lib\opendaptor-spring.jar;..\..\lib\openadaptor-depends.jar  
</pre></div>
<h4>Unix</h4>
<div class="shell"><pre>
  cd example/tutorial
  CLASSPATH=.:../../lib/openadaptor.jar:../../lib/opendaptor-spring.jar:../../lib/openadaptor-depends.jar  
  export CLASSPATH
</pre></div>
<p>NOTE: for simplicity this sets your CLASSPATH environment variable relative to the tutorial
directory, since the entire tutorial will be run from this directory, this should work fine.</p>
<a href="#contents">back to contents</a>

<a name="step1"/>
<h2>Step 1</h2>
<p>This first adaptor <a href="step01.xml" target="_blank">step01.xml</a> exposes a servlet 
interface and outputs data that it receives to
stdout. NOTE: This is deliberately contrived to enable us to send data into the adaptor using
a test web page, ultimately we will replace this with something a bit more realistic. 
To run this adaptor type this</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step01.xml -bean Adaptor
</pre></div>

<p>You should see a flurry of logging which include the openadaptor copyright notice
and licence, it should look like this...</p>

<div class="shell"><pre>
INFO  [Adaptor] Writer registered with Pipeline
INFO  [Adaptor] Servlet registered with Pipeline
INFO  [Adaptor] Writer started
2007-02-13 10:31:03.874::INFO:  Logging to STDERR via org.mortbay.log.StdErrLog
2007-02-13 10:31:03.874::INFO:  jetty-6.0.1
2007-02-13 10:31:03.905::INFO:  Started SocketConnector @ 0.0.0.0:9999
INFO  [Adaptor] Servlet added servlet http://iblongsw336240:9999/*
INFO  [Adaptor] Servlet started
INFO  [Adaptor] waiting for runnables to stop
INFO  [Servlet] Servlet running
</pre></div>

<p>All this and the configuration file will be explained later, but first let's test the adaptor. 
We have provided a web page that will post data to the adaptor servlet interface, open 
<a href="test.html" target="_blank">test.html</a> and give it a try.
You should see the fields you input, echoed by your adaptor, like this</p>
<textarea cols="100" rows="2" readonly="true">
{buySell=BUY, ticker=XYZ, price=100}
</textarea>

<p>Use Ctrl-C to stop the adaptor process cleanly.</p>

<p>The rest of this section explains what has happened and some details about how.</p>

<h3>Understanding the program you ran</h3>
<p>The java program you ran <code>org.openadaptor.spring.SpringApplication</code> is a
helper class that we provide in <code>openadaptor-spring.jar</code>. The config argumemnt 
is a url for a spring XML configuration and the bean argument is 
the name of a bean in the configuration file that implements <code>java.lang.Runnable</code>.
This helper class is not specific to any of the openadaptor code, it simply provides a
convenient way of launching a stand alone process based on a spring XML configuration.</p>

<p>If the url for the configuration file does not specify a protocol then the program
assumes that it is a file url, hence the following are equivalent.</p>

<code>
  java org.openadaptor.spring.SpringApplication -config step01.xml -bean Adaptor
  java org.openadaptor.spring.SpringApplication -config file:step01.xml -bean Adaptor
</code>

<h3>Understanding the spring XML configuration file</h3>
<p>If you understood the previous section then it then it makes sense to look first at the
"Adaptor" bean.</p>

<textarea cols="100" rows="5" readonly="true">

  <bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor">
    <property name="messageProcessor" ref="Pipeline"/>
  </bean>
</textarea>

<p>This represents the top level controller in the process. It manages the processing
lifecycle and co-ordinates the ReadConnectors, Processors and WriteConnectors. This very
simple example has one ReadConnector and one WriteConnector, called "Servlet" and "Writer"
respectively. The ReadConnector "sits there" waiting for data to be POSTED, the Writer
prints any data it receives to the conosle (stdout). Here are the beans in the config
that relate to these two components.</p>

<textarea cols="100" rows="7" readonly="true">

  <bean id="Servlet" class="org.openadaptor.auxil.connector.http.ReadConnectorServlet">
    <property name="port" value="9999"/>
  </bean>
  
  <bean id="Writer" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector"/>
</textarea>

<p>These are linked together by the Pipeline bean, which is configured with an ordered list
of processors. This defines that the output from the Servlet should be "piped" to the Writer.</p>

<textarea cols="100" rows="11" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="Writer"/>
      </list>
    </property>
  </bean>  
</textarea>

<h3>Understanding the log output</h3>
<p>The Adaptor bean is configured with the Pipeline, when the Adaptor bean is "run", the Pipeline
registers all the processors with the Adaptor. If you look at the log output you can see that
the various components are registered and started, the adaptor then waits for the ReadConnectors
that are Runnable to stop.</p>

<p>openadaptor uses the apache commons logging framework, this can utilise a variety of logging
implementation and resolves it's behaviour based on the Java classpath. Our examples will pick
up the log4j logging package and this is controlled by the log4j.properties file in the tutorial dir.</p>

<p>Try uncommenting the DEBUG line (and other example configurations) and rerunning the adaptor. 
log4j is very powerful, please refer to <a href="http://logging.apache.org">log4j</a>
for more information on how to configure log4j.</p>

<h3>Other arguments to the program you ran</h3>
<p><code>org.openadaptor.spring.SpringApplication</code> can also accept a url to a 
java properties file, this enables you to separate out
certain configuration value that are then referred to indeirectly in the config file.
Typically you want to do this for environment specific parameters, so that you can have
a single config that can be used with different properties files for different environments
(test, uat, production, etc...). As with the config url, the helper class will assume that
the protocol is file.</p>

<p>It can also accept a jmx port number argument, If this is specified then the helper class
will automatically start a JMX server and HTTP adaptor, any named beans in the config that have
MBeans will be automatically registered with the MBeanServer. NOTE: alternatively you are free to
use standard spring mechanism for JMX instrumentation.</p>.

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step01.xml -bean Adaptor -jmx 9001
</pre></div>

<p>You should notice that there is now additonal log output that relates to the JMX MBeanServer
and the HTTP adaptor. You can access the jmx HTTP interface using this url 
<a href="http://localhost:9001" target="_blank">http://localhost:9001</a>.</p>

<a href="#contents">back to contents</a>

<a name="step2"/>
<h2>Step 2</h2>
<p>This adaptor <a href="step02.xml" target="_blank">step02.xml</a> 
extends the previous adaptor by adding a processor into the pipeline.
This processor converts a Map that the ServletReadConnector outputs to an XML document. Here is
the additional bean and the modified config for the Pipeline bean.</p>

<textarea cols="100" rows="15" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="XMLConverter"/>
        <ref bean="Writer"/>
      </list>
    </property>
  </bean>  

  <bean id="XMLConverter" class="org.openadaptor.auxil.convertor.xml.OrderedMapToXmlConvertor">
    <property name="rootElementTag" value="Trade"/>
  </bean>
</textarea>

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step02.xml -bean Adaptor
</pre></div>

<p>and test with the test webpage <a href="test.html" target="_blank">test.html</a></p>

<p>What you should see is a small XML document the represents the data that you input.
Something like this</p>

<textarea cols="100" rows="4" readonly="true">

<?xml version="1.0" encoding="ISO-8859-1"?>
<Trade><buySell>SELL</buySell><ticker>ABC</ticker><price>123.56</price></Trade>
</textarea>

<p>What happens now, is that the output from the Servlet is routed to the a processor
that converts the java Map to an xml document (the root element is configured to be "Trade"),
this is then routed to a FileWriteConnector that writes the output to the console (stdout).</p>

<a href="#contents">back to contents</a>

<a name="step3"/>
<h2>Step 3</h2>
<p>This adaptor <a href="step03.xml" target="_blank">step03.xml</a> 
extends the previous adaptor by adding another processor into the pipeline.
This processor validates that the XML against an XML schema file. Here is
the additional bean and the modified config for the Pipeline bean.</p>

<textarea cols="100" rows="16" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="XMLConverter"/>
        <ref bean="Validator"/>
        <ref bean="Writer"/>
      </list>
    </property>
  </bean>
   
  <bean id="Validator" class="org.openadaptor.auxil.processor.xml.XmlValidator">
    <property name="schemaURL" value="schema.xsd"/>
  </bean>
</textarea>    

<p>The processor uses an XML Schema definition file to validate the XML</p>

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step03.xml -bean Adaptor
</pre></div>

<p>and test with the test webpage <a href="test.html" target="_blank">test.html</a>.
If you input a numeric price then the adaptor should behave as it previously
did. However if you input a non numeric price the adaptor will fail and exit.
What happens is that the Validator throws and processing exception, that exception will
go all the way back to the ReadConnector (The Servlet) an cause the adaptor to stop.</p>

<p>openadaptor components can be configured to catch exception and process them, thus enabling
the adaptor to keep running. The Pipeline component (which provides simple routing) can be
configured with a Processor or WriteConnector, any processing exceptions in the adaptor will
be caught and routed to the configured component. This adaptor 
<a href="step03a.xml" target="_blank">step03a.xml</a> illustrates how to configure this feature.
In this case the exception is simply written to an error file.
Here are the additional beans and the modified Pipeline configuration.

<textarea cols="100" rows="18" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="XMLConverter"/>
        <ref bean="Validator"/>
        <ref bean="Writer"/>
      </list>
    </property>
    <property name="exceptionProcessor" ref="ExceptionHandler"/>
  </bean>

  <bean id="ExceptionHandler" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="error.txt"/>
  </bean>
</textarea>    

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step03a.xml -bean Adaptor
</pre></div>

<p>Repeat the previous test,  <a href="test.html" target="_blank">test.html</a>
 this time the invalid xml should be filtered out and written to
a a file called error.txt. The adaptor should keep running when you input an invalid price.</p>

<a href="#contents">back to contents</a>

<a name="step4"/>
<h2>Step 4</h2>
<p>This adaptor <a href="step04.xml" target="_blank">step04.xml</a> 
extends the previous adaptor by replacing the FileWriteConnector with a
JMS Write Connector, that publishes our Trade XML onto a JMS queue. For this
to work we need a JMS implementation. This tutorial is designed to work with
a default installation of the jBoss application server, this is free to download
and should be trivial to install and run. Download a binary distribution from
<a href="http://www.jboss.org">http://www.jboss.org</a>, 
unzip and run from a command prompt using the run.bat/run.sh
scripts provided in the jBoss bin dir.</p>

<p>Here are the additonal beans and the modified Writer bean</p>

<textarea cols="100" rows="17" readonly="true">

  <bean id="JndiConnection" class="org.openadaptor.auxil.connector.jndi.JNDIConnection">
    <property name="initialContextFactory" value="org.jnp.interfaces.NamingContextFactory"/>
    <property name="providerUrl" value="jnp://localhost:1099"/>
  </bean>
  
  <bean id="JmsConnection" class="org.openadaptor.auxil.connector.jms.JMSConnection">
    <property name="jndiConnection" ref="JndiConnection"/>
    <property name="connectionFactoryName" value="ConnectionFactory"/>
  </bean>
  
  <bean id="Writer" class="org.openadaptor.auxil.connector.jms.JMSWriteConnector">
    <property name="destinationName" value="queue/testQueue"/>
    <property name="jmsConnection" ref="JmsConnection"/>
  </bean>

</textarea>    

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step04.xml -bean Adaptor
</pre></div>

<p>When you test, <a href="test.html" target="_blank">test.html</a>, the adaptor will
now publish the valid xml documents to the configured JMS queue. If you want to verify
this then adjust the log4j.properties file so that it logs openadaptor code at DEBUG.
Or if you are feeling bold, set this dynamically via the JMS interface. Or continue to
the next step in which we run a new adaptor that will process the messages on the queue.</p>

<a href="#contents">back to contents</a>

<a name="step5"/>
<h2>Step 5</h2>
<p>This adaptor <a href="step05.xml" target="_blank">step05.xml</a> 
illustrates how to subscribe to the JMS queue. It contains a single read connector
(JMSReadConnector) and a single write connector (FileWriteConnector). As you can
imagine, all it does is get messages from the queue and print them to the console
(stdout). Since this is not an extension of the previous example (a publisher) it
is best to launch another command prompt to continue with the tutorial, you will need
to follow the <a href="#setup">set up instructions</a>. Once you have done that here 
is how to run it</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step05.xml -bean Adaptor
</pre></div>

<p/>You should see the messages that you published to the queue in Step 4. You
can run this adaptor and the adaptor in Step 4, concurrently. Everytime you input
a test trade using the web page <a href="test.html" target="_blank">test.html</a>
you should receive the message in your adaptor that is subscribing to the queue.</p>

<p>However, if you look at the config you will see that in this example
the Pipeline bean has been replaced by a Router bean.</p>

<textarea cols="100" rows="13" readonly="true">

  <bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor">
    <property name="messageProcessor" ref="Router"/>
  </bean>
  
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="Writer"/>
      </map>
    </property>
  </bean>
</textarea>    

<p> A Router allows more complicated linkage between ReadConnectors, Processors and 
WriteConnector. As it's name implies a Router specifies the processing route between the components, 
in this example the processing route is very trivial (in fact we could have used a Pipeline 
bean as before), however subsequent examples will build upon this configuration. Noate that
from the Adaptor's point of view, the Router is simply an IMessageProcessor, just like Pipeline.</p>

<a href="#contents">back to contents</a>

<a name="step6"/>
<h2>Step 6</h2>
<p>This adaptor <a href="step06.xml" target="_blank">step06.xml</a> extends the
previous example and illustrates how to use a standard component to filter out
messages based on their content. This involves adding 2 processor beans.</p>

<p>the first transforms the XML message into something called an ISimpleRecord, this is a Java
interface that allows subsequent processors to access the contents the underlying data. 
In this case the underlying data is the XML document and the first processor bean 
XMLConverter uses dom4J to provide access to the document. Here is the config for this bean.</p>

<textarea cols="100" rows="8" readonly="true">
  <bean id="XMLConverter" class="org.openadaptor.auxil.convertor.simplerecord.ToSimpleRecordConvertor">
    <property name="simpleRecordAccessor">
      <bean class="org.openadaptor.thirdparty.dom4j.Dom4jSimpleRecordAccessor"/>
    </property>
  </bean>

</textarea>    

<p>The second bean, called Filter, does the filtering and this uses a processor that
evaluates a Javascript expression, the Javascript code is a property of the bean and
accesses the contents of the message using XPATH, by virtue of the fact that the
document has been wrapped as an ISimpleRecord. Here is the config for this bean</p>

<textarea cols="100" rows="5" readonly="true">
  <bean id="Filter" class="org.openadaptor.auxil.processor.javascript.JavascriptFilterProcessor">
    <property name="script" value="record.get('/Trade/ticker') == 'XXX'"/>
  </bean>

</textarea>    

<p>And this is the modified config for the Router</p>

<textarea cols="100" rows="11" readonly="true">
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="XMLConverter"/>
        <entry key-ref="XMLConverter" value-ref="Filter"/>
        <entry key-ref="Filter" value-ref="Writer"/>
      </map>
    </property>
  </bean>

</textarea>    

<p>Here is how to run it, (make sure you stop the previous adaptor from Step5)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step06.xml -bean Adaptor
</pre></div>

<p/>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
you should see that messages that have ticker set to "XXX" are discarded.</p>

<a href="#contents">back to contents</a>

<a name="step7"/>
<h2>Step 7</h2>
<p>This adaptor <a href="step07.xml" target="_blank">step07.xml</a> extends the
previous example and illustrates how to use a standard processor to transform 
the XML documemnt into a SQL statement. In this example the SQL statement is simply
written to the console, stdout. This process uses the Velocity 
, refer to <a href="http://velocity.apache.org">http://velocity.apache.org</a> for documentation
of their template language. Here is the config, notice that the velocity template is a property
of the bean (it is also possible to specify the template as a file).</p>

<textarea cols="100" rows="12" readonly="true">

  <bean id="SQLConverter" class="org.openadaptor.thirdparty.velocity.VelocityProcessor">
    <property name="templateString">
      <value>
        INSERT INTO TRADE ('SIDE', 'STOCK', 'PRICE') 
        VALUES ('$data.get('/Trade/buySell')', 
                '$data.get('/Trade/ticker')', 
                $data.get('/Trade/price'))
      </value>
    </property>
  </bean>
</textarea>    

<p>And this is the modified config for the Router</p>

<textarea cols="100" rows="12" readonly="true">

  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="XMLConverter"/>
        <entry key-ref="XMLConverter" value-ref="Filter"/>
        <entry key-ref="Filter" value-ref="SQLConverter"/>
        <entry key-ref="SQLConverter" value-ref="Writer"/>
      </map>
    </property>
  </bean>
</textarea>    

<p>Here is how to run it, (make sure you stop the previous adaptor from Step6)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step07.xml -bean Adaptor
</pre></div>

<p/>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
you should see SQL Statements.</p>

<a href="#contents">back to contents</a>

<a name="step8"/>
<h2>Step 8</h2>
<p>This adaptor <a href="step08.xml" target="_blank">step08.xml</a> extends the
previous example and shows you how to execute the SQL statements against a database.
For simplicity these instructions use hypersonic < a href="http://hsqldb.org">http://hsqldb.org</a>
which is a 100% java lightweight db. For the example to work you will need to run up the hypersonic
server, this is very easy, you simply need to run these commands from a new command promt.</p>

<h4>Windows</h4>
<div class="shell"><pre>
  cd example\tutorial\db
  java -classpath ..\..\..\lib\3rdparty\hsqldb.jar org.hsqldb.Server -database.0 hsql -dbname.0 xdb
</pre></div>
<h4>Unix</h4>
<div class="shell"><pre>
  cd example/tutorial/db
  java -classpath ../../../lib/3rdparty/hsqldb.jar org.hsqldb.Server -database.0 hsql -dbname.0 xdb
</pre></div>

<p>Here is the new Writer bean and a related bean that defines the JDBC Connection.</p>

<textarea cols="100" rows="13" readonly="true">

  <bean id="JdbcConnection" class="org.openadaptor.auxil.connector.jdbc.JDBCConnection">
    <property name="driver" value="org.hsqldb.jdbcDriver"/>
    <property name="url" value="jdbc:hsqldb:hsql://localhost/xdb"/>
    <property name="username" value="sa"/>
    <property name="password" value=""/>
  </bean>

  <bean id="Writer" class="org.openadaptor.auxil.connector.jdbc.writer.JDBCWriteConnector">
    <property name="jdbcConnection" ref="JdbcConnection"/>
  </bean>
</textarea>    

<p>NOTE: The router config doesn't change because we have simply replaced the Writer bean
with an alternative implementation. Here is how to run it, (make sure you stop the previous 
adaptor from Step7)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step08.xml -bean Adaptor
</pre></div>

<p/>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
the SQL statements will be executed against the hypersonic db. There are a couple of
ways to verify this.</p>

<li>The server writes it's state to the hsql.script on shutdown, so you can ctrl-C
the server and look at the contents of example/tutorial/db/hsql.script</li>
<li>use the jdbc parameters with a SQL client to check the contents of the database</li>
<p>Or you could trust us :) </p>
<a href="#contents">back to contents</a>

<a name="step9"/>
<h2>Step 9</h2>
<p>This adaptor <a href="step09.xml" target="_blank">step09.xml</a> extends the
previous example by showing how the Router can be configured to process discarded messages
and processing exceptions. In addition to this we show how to write and integrate your 
own processor.</p>

<p>Here is the modified Router bean</p>

<textarea cols="100" rows="32" readonly="true">

  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="XMLConverter"/>
        <entry key-ref="XMLConverter" value-ref="Filter"/>
        <entry key-ref="Filter" value-ref="CustomProcessor"/>
        <entry key-ref="CustomProcessor" value-ref="SQLConverter"/>
        <entry key-ref="SQLConverter">
          <list>
            <ref bean="Writer"/>
            <ref bean="SqlLog"/>
          </list>
        </entry>
      </map>
    </property>
    <property name="discardMap">
      <map>
        <entry key-ref="Filter" value-ref="DiscardLog"/>
      </map>
    </property>
    <property name="exceptionMap">
      <map>
        <entry key="*">
          <map>
            <entry key="org.openadaptor.core.exception.ProcessingException" value-ref="ErrorLog"/>
          </map>
        </entry>
      </map>
    </property>
  </bean>
</textarea>    

<p>There are a number of significant changes in the above config.</p>

<p>Firstly, the entry in the processMap for SQLConverter is mapped to a list containing 2 beans. 
This means that data output by the SQLConverter should be routed to both beans. The first bean
is the Writer (as before), the other bean is new and is implemented by a FileWriteConnector.</p>

<p>Secondly, the Router has a new property called discardMap this is defines how discarded
data should be routed. It has a single entry which maps the Filter bean to a new bean called
DiscardLog, this is also implemented by a FileWriteConnector. This means any data that is discarded
by the Filter bean is routed to the DiscardLog.</p>

<p>Thirdly, the Router has a new property called exceptionMap, this defines how processing exceptions
are handled. The value is a map of maps, where the key to the first map is either a bean or a wildcard
(as in the example above) and value maps the classname of an exception to a bean (or list of beans).
In the example above this means that ProcessingExceptions thrown by any bean in the adaptor will be
routed to the ErrorLog bean, this is also implemented by a FileWriteConnector.</p>

<p>Here are the new beans</p>

<textarea cols="100" rows="13" readonly="true">

  <bean id="SqlLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/sql.txt"/>
  </bean>
  
  <bean id="DiscardLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/discard.txt"/>
  </bean>
  
  <bean id="ErrorLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/suberror.txt"/>
  </bean>
</textarea>    

<p>Lastly, the Router now includes a new processor bean called CustomProcessor. This is custom code
that is included in the tutorial <a href="src/CustomProcessor.java">src/CustomProcessor.java</a>.
This custom code is a little bit contrived since there are standard component available which
provide this functionality. The processor can be configured to transform a field value based on
a map property. Here is the config.</p>.

<textarea cols="100" rows="10" readonly="true">

  <bean id="CustomProcessor" class="CustomProcessor">
    <property name="field" value="/Trade/buySell"/>
    <property name="map">
      <map>
        <entry key="BUY" value="B"/>
        <entry key="SELL" value="S"/>
      </map>
    </property>
  </bean>
</textarea>    

<p>It transforms the value for the buySell element to "B" or "S", if the incoming value is not "BUY"
or "SELL" then it will throw a ProcessingException.</p>

<p>Before running the example you will need to compile the code. This requires that you have the
JDK (rather than the JRE). These instructions assume that you run the command in the command prompt
that you have been running the adaptor (otherwise set your classpath according to the 
<a href="#setup">set up instructions</a>).</p>

<div class="shell"><pre>
  javac -d . -sourcepath src
</pre></div>

<p>This should create a Java class file called CustomProcessor.class. Here is how to run
the adaptor, (make sure you stop the previous adaptor from Step8)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringApplication -config step09.xml -bean Adaptor
</pre></div>

<p/>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
you should notice the following behaviour changes</p>

<li>All filtered messages, those with ticker = "XXX", are now written to the discard log 
<a href="output/discard.txt">output/discard.txt</a>.</li>
<li>All sucessfully executed SQL statements are now written to the sql log, 
<a href="output/discard.txt">output/discard.txt</a></li>
<li>The buySell column in the db and sql log is now B or S</li>
<li>Trades which have buySell = "?" throw exceptions and the exception plus the message is
written to the the exception log <a href="output/exception.txt">output/discard.txt</a></li>
<p></p>
<a href="#contents">back to contents</a>

</body>


</html>
