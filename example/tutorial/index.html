<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=Cp1252"/>
<STYLE TYPE="text/css">
  .shell    { width: 90%; background-color: #EEEEEE }
  .heading  { width:100%; font-size:14pt; font-weight:bold; border-bottom-style:solid; border-bottom-width:1px; margin-top:40 }
  .back     { text-align: right; font-size:9pt }
</STYLE>

<title>openadaptor tutorial</title>
</head>

<body>
<h1>Tutorial</h1>
<p>This tutorial assumes that you have already managed to install openadaptor, set your
Java CLASSPATH and verify that you can run the simple adaptor. If not then please refer 
to the instructions in <a href="../readme.html" target="_blank">example/readme.html</a>.</p>

<p>It is strongly recommended that you read the openadaptor whitepaper, before attempting
this tutorial. This provides an overview of the what openadaptor is designed to do, it's high
level design and some terminology that is used in this tutorial.</p>

<p>In this tutorial you will run a series of adaptors that illustrate openadaptor, the
instructions show you how to run these from the command prompt / shell. The examples
are simplistic in order make them easy to run and experiment with. All of the adaptors
are expressed as spring framework configuration files. 
The later examples use JMS and you will need to install and run a default jboss 
implementation for these to work, other examples illustrate writing data to a database,
for simplicity we use hypersonic db, which you will need to "run up". You do not need to be
familiar with jBoss or hypersonic.</p>

<a name="contents"></a>
<h2>Contents</h2>
<ol>
<li><a href="#initial">Set Up</a></li>
<li><a href="#step1">Step  1: A Test Adaptor</a></li>
<li><a href="#step2">Step  2: XML Conversion</a></li>
<li><a href="#step3">Step  3: XML Validation</a></li>
<li><a href="#step4">Step  4: JMS Publishing</a></li>
<li><a href="#step5">Step  5: JMS Subscribing</a></li>
<li><a href="#step6">Step  6: Message Filtering</a></li>
<li><a href="#step7">Step  7: SQL Conversion</a></li>
<li><a href="#step8">Step  8: SQL Execution</a></li>
<li><a href="#step9">Step  9: Discard and Exception Routing and Custom Code</a></li>
<li><a href="#step10">Step 10: Reading from a File</a></li>
<li><a href="#step11">Step 11: Exception Handling</a></li>
<li><a href="#summary">Summary</a></li>
</ol>

<!--
    Initial Setup
-->
<a name="initial"></a>
<h2>Set Up</h2>
<p>launch a command prompt / shell and follow these these instructions</p>
<h4>Windows</h4>
<div class="shell"><pre>
  cd example\tutorial
  .\setclasspath.bat
</pre></div>
<h4>Unix</h4>
<div class="shell"><pre>
  cd example/tutorial
  source setclasspath.sh
</pre></div>
<p>For simplicity this sets your CLASSPATH environment variable relative to the tutorial
directory, since the entire tutorial will be run from this directory, this should work fine.</p>
<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 1 - A text addaptor
-->
<a name="step1"></a>
<h2>Step 1</h2>
<p>This first adaptor <a href="step01.xml" target="_blank">step01.xml</a> exposes a servlet 
interface and outputs data that it receives to the console (stdout).
This is deliberately contrived to enable us to send data into the adaptor using
a test web page, ultimately we will replace this with something a bit more realistic. 
To run this adaptor type this in the aformentioned command prompt / shell.</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step01.xml 
</pre></div>

<p>You should see a flurry of logging which includes the openadaptor copyright notice
and licence, the last line of the log should look like this...</p>

<div class="shell"><pre>
INFO  [Adaptor] Writer registered with Pipeline
INFO  [Adaptor] Servlet registered with Pipeline
INFO  [Adaptor] Writer started
2007-02-13 10:31:03.874::INFO:  Logging to STDERR via org.mortbay.log.StdErrLog
2007-02-13 10:31:03.874::INFO:  jetty-6.0.1
2007-02-13 10:31:03.905::INFO:  Started SocketConnector @ 0.0.0.0:9999
INFO  [Adaptor] Servlet added servlet http://iblongsw336240:9999/*
INFO  [Adaptor] Servlet started
INFO  [Adaptor] waiting for runnables to stop
INFO  [Servlet] Servlet running
</pre></div>

<p>All this and the configuration file will be explained later, but first let's test the adaptor. 
We have provided a web page that contains a form which will post data to the adaptor servlet interface. 
Open <a href="test.html" target="_blank">test.html</a> and give it a try.
You should see the fields you input, echoed by your adaptor, like this</p>
<textarea cols="100" rows="2" readonly="true">
{buySell=BUY, ticker=XYZ, price=100}
</textarea>

<p>Use Ctrl-C to stop the adaptor process cleanly.</p>

<p>The rest of this section explains what has happened and some details about how.</p>

<h3>Understanding the program you ran</h3>
<p>The java program you ran <code>org.openadaptor.spring.SpringAdaptor</code> is a
helper class that we provide in <code>openadaptor-spring.jar</code>. The config argumemnt 
is a url for a spring XML configuration.</p>

<p>If the url for the configuration file does not specify a protocol then the program
assumes that it is a file url, hence the following are equivalent.</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step01.xml 
  java org.openadaptor.spring.SpringAdaptor -config file:step01.xml 
</pre></div>

<h3>Understanding the spring XML configuration file</h3>
<p>The first part of the configuration file to look at is the "Adaptor" bean. Here it is</p>

<textarea cols="100" rows="5" readonly="true">

  <bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor">
    <property name="messageProcessor" ref="Pipeline"/>
  </bean>
</textarea>

<p>This represents the top level controller in the process. It manages the processing
lifecycle and co-ordinates the ReadConnectors, Processors and WriteConnectors. This very
simple example has one ReadConnector and one WriteConnector, called "Servlet" and "Writer"
respectively. The ReadConnector "sits there" waiting for data to be POSTED, the Writer
prints any data it receives to the conosle (stdout). Here are the beans in the config
that relate to these two components.</p>

<textarea cols="100" rows="7" readonly="true">

  <bean id="Servlet" class="org.openadaptor.auxil.connector.http.ReadConnectorServlet">
    <property name="port" value="9999"/>
  </bean>
  
  <bean id="Writer" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector"/>
</textarea>

<p>These are linked together by the Pipeline bean, it's processors property is an ordered list of beans. 
This defines that the output from the Servlet should be "piped" to the Writer.</p>

<textarea cols="100" rows="11" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="Writer"/>
      </list>
    </property>
  </bean>  
</textarea>

<h3>Understanding the log output</h3>
<p>The Adaptor bean is configured with the Pipeline, when the Adaptor bean is "run", the Pipeline
registers all the processors with the Adaptor. If you look at the log output you can see that
the various components are registered and started, the adaptor then waits for the ReadConnectors
that are Runnable to stop.</p>

<p>openadaptor uses the apache commons logging framework, this can utilise a variety of logging
implementation and resolves it's behaviour based on the Java classpath. Our examples will pick
up the log4j logging package and this is controlled by the log4j.properties file in the tutorial dir.</p>

<p>Try uncommenting the DEBUG line (and other example configurations) and rerunning the adaptor. 
log4j is very powerful, please refer to <a href="http://logging.apache.org" target="_blank">log4j</a>
for more information on how to configure log4j.</p>

<h3>Other arguments to the program you ran</h3>
<p><code>org.openadaptor.spring.SpringAdaptor</code> can actually accept multiple config urls.
Typically you want to do this to re-use common spring components or to "mix-in" environment specific 
properties (test, uat, production, etc...).For example</p> 

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step01.xml -config uat.xml
</pre></div>
  
<p>The config url can be based on the following protocols:</p>
<li>file:</li>
<li>http:</li>
<li>classpath:</li>
<br/>
      
<p>The program can accept a bean argument, which identifies the Adaptor bean that it should run. If
this is not specified then the program "looks" for a bean of type Adaptor, and if one and only one is found
it defaults to this. Hence the following is equivalent:</p>
  
<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step01.xml
  java org.openadaptor.spring.SpringAdaptor -config step01.xml -bean Adaptor
</pre></div>
 
<p>The program can also accept a jmx port number argument, If this is specified then the helper class
will automatically start a JMX server and HTTP adaptor, any named beans in the config that have
MBeans will be automatically registered with the MBeanServer. NOTE: alternatively you are free to
use standard spring mechanism for JMX instrumentation. Try rerunning the adaptor like this</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step01.xml -jmxport 9001
</pre></div>

<p>You should notice that there is now additonal log output that relates to the JMX MBeanServer
and the HTTP adaptor. You can access the jmx HTTP interface using this url 
<a href="http://localhost:9001" target="_blank">http://localhost:9001</a>.</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 2 - XML Conversion
-->
<a name="step2"></a>
<h2>Step 2</h2>
<p>This adaptor <a href="step02.xml" target="_blank">step02.xml</a> 
extends the previous adaptor by adding a processor bean into the pipeline.
This processor converts a Map that the ServletReadConnector outputs to an XML document. Here is
the additional bean and the modified config for the Pipeline bean.</p>

<textarea cols="100" rows="15" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="XMLConverter"/>
        <ref bean="Writer"/>
      </list>
    </property>
  </bean>  

  <bean id="XMLConverter" class="org.openadaptor.auxil.convertor.xml.OrderedMapToXmlConvertor">
    <property name="rootElementTag" value="Trade"/>
  </bean>
</textarea>

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step02.xml 
</pre></div>

<p>and test with the test webpage <a href="test.html" target="_blank">test.html</a></p>

<p>What you should see is a small XML document containing the data that you input.
Something like this</p>

<textarea cols="100" rows="4" readonly="true">

<?xml version="1.0" encoding="ISO-8859-1"?>
<Trade><buySell>SELL</buySell><ticker>ABC</ticker><price>123.56</price></Trade>
</textarea>

<p>What is happening here, is that the output from the Servlet is "piped" to XMLConverter bean.
This converts the map of data into an XML document (the root element is configured to be "Trade"),
this output is then "piped" to the Writer bean which writes the output to the console (stdout).</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 3 - XML Validation
-->
<a name="step3"></a>
<h2>Step 3</h2>
<p>This adaptor <a href="step03.xml" target="_blank">step03.xml</a> 
extends the previous adaptor by adding another processor bean into the pipeline.
This processor validates that the XML against an XML schema file. Here is
the additional bean and the modified config for the Pipeline bean.</p>

<textarea cols="100" rows="16" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="XMLConverter"/>
        <ref bean="Validator"/>
        <ref bean="Writer"/>
      </list>
    </property>
  </bean>
   
  <bean id="Validator" class="org.openadaptor.auxil.processor.xml.XmlValidator">
    <property name="schemaURL" value="schema.xsd"/>
  </bean>
</textarea>    

<p>The processor uses an XML Schema definition file to validate the XML</p>

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step03.xml 
</pre></div>

<p>and test with the test webpage <a href="test.html" target="_blank">test.html</a>.
If you input a numeric price then the adaptor should behave as it previously
did. However if you input a non numeric price the adaptor will fail and exit.
What happens is that the Validator throws and processing exception, that exception will
go all the way back to the ReadConnector (The Servlet) an cause the adaptor to stop.</p>

<p>openadaptor components can be configured to catch exception and process them, thus enabling
the adaptor to keep running. The Pipeline component (which provides simple routing) can be
configured with a Write Connector, any processing exceptions in the adaptor will
be caught and routed to the configured component. This adaptor 
<a href="step03a.xml" target="_blank">step03a.xml</a> illustrates how to configure this feature.
In this case the exception is simply written to an error file.
Here are the additional beans and the modified Pipeline configuration.</p>

<textarea cols="100" rows="18" readonly="true">

  <bean id="Pipeline" class="org.openadaptor.core.router.Pipeline">
    <property name="processors">
      <list>
        <ref bean="Servlet"/>
        <ref bean="XMLConverter"/>
        <ref bean="Validator"/>
        <ref bean="Writer"/>
      </list>
    </property>
    <property name="exceptionProcessor" ref="ExceptionHandler"/>
  </bean>

  <bean id="ExceptionHandler" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/puberror.txt"/>
  </bean>
</textarea>    

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step03a.xml 
</pre></div>

<p>Repeat the previous test,  <a href="test.html" target="_blank">test.html</a> this time the
  invalid xml should be filtered out and written to a file called <a href="output/puberror.txt">
  puberror.txt</a>. The adaptor should keep running when you input an invalid price.</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 4 - JMS Publishing
-->
<a name="step4"></a>
<h2>Step 4</h2>
<p>This adaptor <a href="step04.xml" target="_blank">step04.xml</a> 
extends the previous adaptor by replacing the FileWriteConnector with a
JMS Write Connector, that publishes our Trade XML onto a JMS queue. For this
to work we need a JMS implementation. This tutorial is designed to work with
a default installation of the jBoss application server, this is free to download
and should be trivial to install and run. Download a binary distribution from
<a href="http://www.jboss.org" target="_blank">http://www.jboss.org</a>,
unzip and run from a command prompt using the run.bat/run.sh
scripts provided in the jBoss bin dir. In addition to this you will need to copy
the following jar file to the opendapator lib\3rdparty dir</p>

<pre>
  jboss-X.Y.Z/client/jbossall-client.jar
</pre>

<p>Here are the additonal beans and the modified Writer bean</p>

<textarea cols="100" rows="17" readonly="true">

  <bean id="JndiConnection" class="org.openadaptor.auxil.connector.jndi.JNDIConnection">
    <property name="initialContextFactory" value="org.jnp.interfaces.NamingContextFactory"/>
    <property name="providerUrl" value="jnp://localhost:1099"/>
  </bean>
  
  <bean id="JmsConnection" class="org.openadaptor.auxil.connector.jms.JMSConnection">
    <property name="jndiConnection" ref="JndiConnection"/>
    <property name="connectionFactoryName" value="ConnectionFactory"/>
  </bean>
  
  <bean id="Writer" class="org.openadaptor.auxil.connector.jms.JMSWriteConnector">
    <property name="destinationName" value="queue/testQueue"/>
    <property name="jmsConnection" ref="JmsConnection"/>
  </bean>

</textarea>    

<p>Run it like this (make sure you stop the previous adaptor)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step04.xml 
</pre></div>

<p>When you test, <a href="test.html" target="_blank">test.html</a>, the adaptor will
now publish the valid xml documents to the configured JMS queue. If you want to verify
this then adjust the log4j.properties file so that it logs openadaptor code at DEBUG.
Or continue to
the next step in which we run a new adaptor that will process the messages in the queue.</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 5 - JMS Subscribing
-->
<a name="step5"></a>
<h2>Step 5</h2>
<p>This adaptor <a href="step05.xml" target="_blank">step05.xml</a> 
illustrates how to subscribe to the JMS queue. It contains a single read connector
(JMSReadConnector) and a single write connector (FileWriteConnector). As you can
imagine, all it does is get messages from the queue and print them to the console
(stdout). Since this is not an extension of the previous example (a publisher) it
is best to launch another command prompt to continue with the tutorial, you will need
to follow the <a href="#setup">set up instructions</a>. Once you have done that here 
is how to run it</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step05.xml 
</pre></div>

<p>You should see the messages that you published to the queue in Step 4. You
can run this adaptor and the adaptor in Step 4, concurrently. Everytime you input
a test trade using the web page <a href="test.html" target="_blank">test.html</a>
you should receive the message in your adaptor that is subscribing to the queue.</p>

<p>If you look at the config you will see that in this example
the Pipeline bean has been replaced by a Router bean. Here is the config.</p>

<textarea cols="100" rows="13" readonly="true">

  <bean id="Adaptor" class="org.openadaptor.core.adaptor.Adaptor">
    <property name="messageProcessor" ref="Router"/>
  </bean>
  
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="Writer"/>
      </map>
    </property>
  </bean>
</textarea>    

<p>A Router allows more complicated linkage between ReadConnectors, Processors and 
WriteConnector. As it's name implies a Router specifies the processing route between the components, 
in this example the processing route is very trivial (in fact we could have used a Pipeline 
bean as before), however subsequent examples will build upon this configuration. Note that
from the Adaptor's point of view, the Router is simply an IMessageProcessor, just like Pipeline.</p>

<p>A Pipeline is actually just a simplified Router in which the processMap is infered from the
ordered list of processors.</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 6 - Message Filtering
-->
<a name="step6"></a>
<h2>Step 6</h2>
<p>This adaptor <a href="step06.xml" target="_blank">step06.xml</a> extends the
previous example and illustrates how to use a standard component to filter out
messages based on their content. This involves adding 2 processor beans.</p>

<p>The first transforms the XML message into something called an ISimpleRecord, this is an
interface that allows subsequent processors to access the contents the underlying data. 
In this case the underlying data is the XML document and the first processor bean 
XMLConverter uses dom4J to provide access to the document. Here is the config for this bean.</p>

<textarea cols="100" rows="8" readonly="true">
  <bean id="XMLConverter" class="org.openadaptor.auxil.convertor.simplerecord.ToSimpleRecordConvertor">
    <property name="simpleRecordAccessor">
      <bean class="org.openadaptor.thirdparty.dom4j.Dom4jSimpleRecordAccessor"/>
    </property>
  </bean>

</textarea>    

<p>The second bean, called Filter, does the filtering and this uses a processor that
evaluates a Javascript expression, the Javascript code is a property of the bean and
accesses the contents of the message using XPATH, by virtue of the fact that the
underlying data is an XML document. Here is the config for this bean</p>

<textarea cols="100" rows="5" readonly="true">
  <bean id="Filter" class="org.openadaptor.auxil.processor.javascript.JavascriptFilterProcessor">
    <property name="script" value="record.get('/Trade/ticker') == 'XXX'"/>
  </bean>

</textarea>    

<p>And this is the modified config for the Router</p>

<textarea cols="100" rows="11" readonly="true">
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="XMLConverter"/>
        <entry key-ref="XMLConverter" value-ref="Filter"/>
        <entry key-ref="Filter" value-ref="Writer"/>
      </map>
    </property>
  </bean>

</textarea>    

<p>Here is how to run it, (make sure you stop the previous adaptor from Step5 but leave the JMS
  publisher from Step4 running)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step06.xml 
</pre></div>

<p>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
you should see that messages that have a <b>ticker</b> set to "XXX" are discarded.</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 7 - SQL Conversion
-->
<a name="step7"></a>
<h2>Step 7</h2>
<p>This adaptor <a href="step07.xml" target="_blank">step07.xml</a> extends the
previous example and illustrates how to use a standard processor to transform 
the XML documemnt into a SQL statement. In this example the SQL statement is simply
written to the console, stdout. This process uses the Velocity 
, refer to <a href="http://velocity.apache.org" target="_blank">http://velocity.apache.org</a> for documentation
of their template language. Here is the config, notice that the velocity template is a property
of the bean (it is also possible to specify the template as a file).</p>

<textarea cols="100" rows="12" readonly="true">

  <bean id="SQLConverter" class="org.openadaptor.thirdparty.velocity.VelocityProcessor">
    <property name="templateString">
      <value>
        INSERT INTO TRADE ('SIDE', 'STOCK', 'PRICE') 
        VALUES ('$data.get('/Trade/buySell')', 
                '$data.get('/Trade/ticker')', 
                $data.get('/Trade/price'))
      </value>
    </property>
  </bean>
</textarea>    

<p>And this is the modified config for the Router</p>

<textarea cols="100" rows="12" readonly="true">

  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="XMLConverter"/>
        <entry key-ref="XMLConverter" value-ref="Filter"/>
        <entry key-ref="Filter" value-ref="SQLConverter"/>
        <entry key-ref="SQLConverter" value-ref="Writer"/>
      </map>
    </property>
  </bean>
</textarea>    

<p>Here is how to run it, (make sure you stop the previous adaptor from Step6 but leave the JMS
  publisher from Step4 running). Remember that the adaptor will still filter out messages with
  tickers of XXX so change it back to something else.</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step07.xml 
</pre></div>

<p>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
you should see SQL Statements.</p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 8 - SQL Execution
-->
<a name="step8"></a>
<h2>Step 8</h2>
<p>This adaptor <a href="step08.xml" target="_blank">step08.xml</a> extends the
previous example and shows you how to execute the SQL statements against a database.
For simplicity these instructions use hypersonic <a href="http://hsqldb.org" target="_blank">http://hsqldb.org</a>
which is a 100% java lightweight db. For the example to work you will need to run up the hypersonic
server, this is very easy, you simply need to run these commands from a new command promt.</p>

<h4>Windows</h4>
<div class="shell"><pre>
  cd example\tutorial\db
  java -classpath ..\..\..\lib\3rdparty\hsqldb.jar org.hsqldb.Server -database.0 hsql -dbname.0 xdb
</pre></div>
<h4>Unix</h4>
<div class="shell"><pre>
  cd example/tutorial/db
  java -classpath ../../../lib/3rdparty/hsqldb.jar org.hsqldb.Server -database.0 hsql -dbname.0 xdb
</pre></div>

<p>Here is the new Writer bean and a related bean that defines the JDBC Connection.</p>

<textarea cols="100" rows="13" readonly="true">

  <bean id="JdbcConnection" class="org.openadaptor.auxil.connector.jdbc.JDBCConnection">
    <property name="driver" value="org.hsqldb.jdbcDriver"/>
    <property name="url" value="jdbc:hsqldb:hsql://localhost/xdb"/>
    <property name="username" value="sa"/>
    <property name="password" value=""/>
  </bean>

  <bean id="Writer" class="org.openadaptor.auxil.connector.jdbc.writer.JDBCWriteConnector">
    <property name="jdbcConnection" ref="JdbcConnection"/>
  </bean>
</textarea>    

<p>Notice that the router config doesn't change because we have simply replaced the Writer bean
with an alternative implementation. Here is how to run it, (make sure you stop the previous 
adaptor from Step7 but leave the JMS publisher from Step4 running)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step08.xml 
</pre></div>

<p>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
the SQL statements will be executed against the hypersonic db. There are a couple of
ways to verify this.</p>

<ul>
  <li>The server writes a log file, tail the hsql.log file (note the logs take a second or two
    to update)</li>
  <li>use the jdbc parameters with a SQL client to check the contents of the database</li>
</ul>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
    Step 9 - Discard and Exception Routing and Custom Code
-->
<a name="step9"></a>
<h2>Step 9</h2>
<p>This adaptor <a href="step09.xml" target="_blank">step09.xml</a> extends the
previous example by showing how the Router can be configured to process discarded messages, 
how the map properties of the Router can specify mulitple 
destinations, and how to write and integrate a custom processor.</p>

<p>Here is the modified Router bean</p>

<textarea cols="100" rows="22" readonly="true">

  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <entry key-ref="Reader" value-ref="XMLConverter"/>
        <entry key-ref="XMLConverter" value-ref="Filter"/>
        <entry key-ref="Filter" value-ref="CustomProcessor"/>
        <entry key-ref="CustomProcessor" value-ref="SQLConverter"/>
        <entry key-ref="SQLConverter">
          <list>
            <ref bean="Writer"/>
            <ref bean="SqlLog"/>
          </list>
        </entry>
      </map>
    </property>
    <property name="discardMap">
      <map>
        <entry key-ref="Filter" value-ref="DiscardLog"/>
      </map>
    </property>
  </bean>
</textarea>    

<p>There are a number of significant changes in the above config.</p>

<p>Firstly, the entry in the processMap for SQLConverter is mapped to a list containing 2 beans. 
This means that data output by the SQLConverter should be routed to both beans. The first bean
is the Writer (as before), the other bean is new and is implemented by a FileWriteConnector.</p>

<p>Secondly, the Router has a new property called discardMap this is defines how discarded
data should be routed. It has a single entry which maps the Filter bean to a new bean called
DiscardLog, this is also implemented by a FileWriteConnector. This means any data that is discarded
by the Filter bean is routed to the DiscardLog.</p>

<p>Here are the new beans</p>

<textarea cols="100" rows="13" readonly="true">

  <bean id="SqlLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/sql.txt"/>
  </bean>
  
  <bean id="DiscardLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/discard.txt"/>
  </bean>
  
  <bean id="ErrorLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/suberror.txt"/>
  </bean>
</textarea>    

<p>Lastly, the Router now includes a new processor bean called CustomProcessor. This is custom code
that is included in the tutorial <a href="src/CustomProcessor.java" target="_blank">src/CustomProcessor.java</a>.
This custom code is a little bit contrived since there are standard component available which
provide this functionality. The processor can be configured to transform a field value based on
a map property. Here is the config.</p>

<textarea cols="100" rows="10" readonly="true">

  <bean id="CustomProcessor" class="CustomProcessor">
    <property name="field" value="/Trade/buySell"/>
    <property name="map">
      <map>
        <entry key="BUY" value="B"/>
        <entry key="SELL" value="S"/>
      </map>
    </property>
  </bean>
</textarea>    

<p>It transforms the value for the buySell element to "B" or "S", if the incoming value is not
  "BUY" or "SELL" then it will throw a ProcessingException.</p>

<p>Before running the example you will need to compile the code. This requires that you have the
  JDK (rather than the JRE). These instructions assume that you run the command in the command
  prompt that you have been running the adaptor (otherwise set your classpath according to the
  <a href="#setup">set up instructions</a>).</p>

<h4>Windows</h4>
<div class="shell"><pre>
  javac -d . src\CustomProcessor.java
</pre></div>
<h4>Unix</h4>
<div class="shell"><pre>
  javac -d . src/CustomProcessor.java
</pre></div>

<p>This should create a Java class file called CustomProcessor.class. Here is how to run the
  adaptor, (make sure you stop the previous adaptor from Step8 but leave the JMS publisher
  from Step4 running)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step09.xml 
</pre></div>

<p>When you test with the webpage <a href="test.html" target="_blank">test.html</a>
you should notice the following behaviour changes</p>

<li>All filtered messages, those with ticker = "XXX", are now written to the discard log 
<a href="output/discard.txt" target="_blank">output/discard.txt</a>.</li>
<li>All sucessfully executed SQL statements are now written to the sql log, 
<a href="output/sql.txt" target="_blank">output/sql.txt</a></li>
<li>The buySell column in the db and sql log is now B or S</li>
<li>Trades which have buySell = "?" throw exceptions and the exception plus the message is
written to the the exception log <a href="output/suberror.txt" target="_blank">output/suberror.txt</a></li>
<p></p>

<p class="back"><a href="#contents">back to contents</a></p>


<!--
      Step 10 - Reading from a File
-->
<a name="step10"></a>
<h2>Step 10</h2>
<p>This adaptor <a href="step10.xml" target="_blank">step10.xml</a> extends the
adaptor in Step 4. It replaces the servlet input with a read connector which
reads lines of character data from a file and a processor which parses delimited
fields from those lines. The connector and processor are wrapped in a ReadNode.
Here is the bean.</p>

<textarea cols="100" rows="24" readonly="true">

  <bean id="FileReader" class="org.openadaptor.core.node.ReadNode">
    <property name="connector">
      <bean class="org.openadaptor.auxil.connector.iostream.reader.FileReadConnector">
        <property name="filename" value="input/data.txt"/>
        <property name="dataReader">
          <bean class="org.openadaptor.auxil.connector.iostream.reader.string.LineReader"/>
        </property>
      </bean>
    </property>
    <property name="processor">
      <bean class="org.openadaptor.auxil.convertor.delimited.DelimitedStringToOrderedMapConvertor">
        <property name="delimiter" value=","/>
        <property name="fieldNames">
          <list>
            <value>buySell</value>
            <value>ticker</value>
            <value>price</value>
          </list>
        </property>
      </bean>
    </property>
  </bean>
</textarea>    

<p>The input is the contents of <a href="input/data.txt" target="_blank">input/data.txt</a>. This
  example illustrates how file based connectors can be used for both batch file processing and as
  part of testing. It also highlights some of the implementation of openadaptor. In the previous
  examples adaptors where assembled from ReadConnectors, Processors and WriteConnectors, however
  the adaptor framework actually deals with implementations of IMessageProcessor and IRunnable
  (See the java docs). The classes that actually implement these interfaces are ReadNode,
  ProcessorNode and WriteNode respectively. These classes provide the transaction management,
  batching and exception capture capabilities. For convenience (and brevity in the configurations),
  Routers and Pipelines wrap / "autobox" ReadConnectors, Processors and WriteConnectors. However
  if you can still couple a connector and processor together by creating ReadNode and WriteNode
  beans explicitly, as we do in this case.</p>

<p>Here is how to run the adaptor, (make sure you stop the previous adaptor from Step4. Leave the
  adaptor from Step9 running to see the output from the JMS queue)</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step10.xml 
</pre></div>

<p>The supplied data file should produce two succssful SQL updates, a dicarded XXX message, a JMS
  subscriber error for the message with the invalid buy/sell value and a JMS publisher error for
  the message with the invalid price.</p>

<p>When you run this the adaptor will process the contents of the file and exit cleanly, if you are
  running the the adaptor in Step 9 then you should see it receive this data as before.</p>

<p class="back"><a href="#contents">back to contents</a></p>

<!--
      Step 11 - Exception Handling 
-->
<a name="step11"></a>
<h2>Step 11</h2>
<p>This example demonstrates OA exception handling capabilities.</p>
 
<p>Exception handling refers to adaptor's behaviour when one of its components produces a Java error or a Java exception.
By default the exception handling is disabled. This means that the first exception that occurs will be logged to the standard log4j logs and will not
be propagated outside of the OA scope. The adaptor will shut down. 
To enable exception handling the exceptionProcessor property needs to be set on the Router class.  
Any valid node, for example a data processor or a write connector, can be used as an exceptionProcessor. Typically 
though, it'll be a simple file writer connector:</p>

<textarea cols="110" rows="12" readonly="true">
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processors">
      ....
      ....
    </property>
    <property name="exceptionProcessor" ref="ExceptionHandler"/>
  </bean>
  
  <bean id="ExceptionHandler" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="errors.log"/>
  </bean>
</textarea>    

<p>This is staightforward and likely to be sufficient for the majority of adaptors. 
It will cause all instances of java.lang.Exception and subclasses thrown in any 
of adaptor's nodes to be caught and processed by the node defined here as the ExceptionHandler - a file write connector. 
This simply means 
the exception will be written to a log file at the specified location. When that's done the adaptor will continue to work 
and to process subsequent data records. The role of the log file is informative only - it can be viewed but 
does not provide a way of refeeding the erroneous data back into the adaptor.</p>


<p>If for some reason this basic exception handler isn't enough, OA provides more advanced ways of defining an 
exceptionProcessor:</p>

<h3>a) Compound Exception Handler</h3>

The exceptionProcessor can be made up of any number of nodes which can branch off just like any other nodes that take part in  
the 'normal' processing flow. However, such composite exceptionProcessor should be assembled carefully and any 
user-defined implementations of OA interfaces that take part in exception handling should be programmed defensively 
and try to avoid throwing exceptions themselves. Exceptions thrown by the exceptionProcessor won't be
handled to avoid a potential indefinite exception catch-rethrow cycle, they'll be treated like normal exceptions
when the exception handling is disabled, which means they'll be logged in standard logs and the adaptor will then shut down. 


<br/>Branching in the exception handler may be useful in situations when information about errors is to be sent to multiple destinations.
For example, it needs to be logged but also generate an an e-mail alert to application owners
and 'chat' a warning to the organisation's instant messaging system. Let's look at an admittedly contrived example: <br/><br/>

<textarea cols="110" rows="22" readonly="true">
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processors">
      <!-- Normal flow path -->
      <entry key-ref="Reader" value-ref="Processor"/>
      <entry key-ref="Processor" value-ref="Writer"/>
        
      <!-- Exception processing path --> 
      <entry key-ref="ExceptionHandlerProxy">
        <list>
          <ref bean="ExceptionConverter"/>
          <ref bean="FileWriter"/>
        </list>
      </entry>
      <entry key-ref="ExceptionConverter" value-ref="XMLConverter"/> 
      <entry key-ref="XMLConverter" value-ref="ConsoleWriter"/>   
    </property>
    
    <property name="exceptionProcessor" ref="ExceptionHandlerProxy"/>
  </bean>

  <bean id="ExceptionHandlerProxy" class="org.openadaptor.core.exception.ExceptionHandlerProxy"/>
 
</textarea> 

<br/><br/>

In the simple example above the org.openadaptor.core.exception.ExceptionHandlerProxy is used as an exception handling entry
point that implements a fan-out and redirects handling to ExceptionConverter and FileWriter. The ExceptionConverter converts exceptions to key-value pairs which
are then sent to XMLConverter and then printed to the console as XML. On a parallel path, the exceptions are written to
a log file.



<br/><br/>

<h3>b) Exception Map</h3>

By defining an exceptionProcessor on the Router we make it the default handler for all exception types, 
which means all exceptions will be handled by one and the same exceptionProcessor (perhaps consisting of a number of different
nodes as shown in the preceding paragraph, but as a whole one and the same processor nonetheless). This behaviour can be fine-tuned. 
Different exception processors can be set up to handle different exception types.
This is achieved by defining the exceptionProcessor as an org.openadaptor.core.exception.ExceptionHandlerProxy with
a redefined exception routing map, as in this sample:<br/><br/>
<textarea cols="120" rows="24" readonly="true">
  <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processors">
       ...
    </property>
    <property name="exceptionProcessor" ref="ExceptionHandler"/>
  </bean>
  
  <bean id="ExceptionHandler" class="org.openadaptor.core.exception.ExceptionHandlerProxy">
    <property name="exceptionMap">
      <map>
        <entry key="org.openadaptor.core.exception.ProcessingException" value-ref="ProcessingExceptionLog"/>
        <entry key="java.lang.Exception" value-ref="OtherExceptionsLog"/> 
      </map>
    </property>
  </bean>
  
  <bean id="ProcessingExceptionLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/processingExceptions.log"/>
  </bean>
  
  <bean id="OtherExceptionsLog" class="org.openadaptor.auxil.connector.iostream.writer.FileWriteConnector">
    <property name="filename" value="output/otherExceptions.log"/>
  </bean>
</textarea> 

<br/><br/>

All ProcessingExceptions and its subclasses here will be written to the processor called ProcessingExceptionLog, all
other errors will go to OtherExceptionsLog. 

<p>The ExceptionHandler has a new property called exceptionMap, which defines how processing exceptions
are handled. The value is a map of maps, where the key to the first map is either a bean or a wildcard
(as in the example above) and the value is a map between the exception and a bean (or list of beans).
In the example above this means that ProcessingExceptions thrown by any bean in the adaptor will be
routed to the ErrorLog bean, this is also implemented by a FileWriteConnector.</p>

<h3>c) The Message Hospital</h3>
Lastly, an exception handler conventionally called The Message Hospital can be used to write exceptions to a 
predefined table in the database. Other than The Message Hospital respects the format of the table it is writing to, there is nothing special about it. It is using 
two standard components - ExceptionToOrderedMapConverter to convert exceptions to a map, and JDBCWriteConnector to store the exceptions in the database.
The Message Hostpital stores information such as exception class name, originating component name, exception timestamp and 
- most importantly - the user data which caused the exception. The table can either be used for informative purpose 
only or as a staging area where the user data can be fixed and then read back to OA for another attempt of processing. 
The HospitalReader can be used to read the data from The Message Hospital back to the OA. Again, the HospitalReader is nothing more 
than a plain JDBCReadConnector that reads from the hospital schema.
OA does not provide any ready-to-use tools for editing user data in the hospital at present.
Although any RDMS can be used for the hospital, HospitalWriter and HospitalReader connectors assume certain 
structure of the table which needs to be created beforehand. SQL scripts are provided for Sybase and HSQL.

<br/><br/>
<textarea cols="150" rows="25" readonly="true">
   <bean id="Router" class="org.openadaptor.core.router.Router">
    <property name="processMap">
      <map>
        <!-- Normal flow -->
        ...
      
        <!-- Processing exceptions -->
        <entry key-ref="ExceptionConvertor" value-ref="HospitalWriter"/> 
      </map>
    </property>
    <property name="exceptionProcessor" ref="ExceptionConvertor"/>
  </bean>
  
  <bean id="ExceptionConvertor" class="org.openadaptor.auxil.convertor.exception.ExceptionToOrderedMapConvertor"/>
  
  <bean id="HospitalWriter" class="org.openadaptor.auxil.connector.jdbc.writer.JDBCWriteConnector">
    <description>Writer which inserts data into test table.</description>
    <property name="jdbcConnection" ref="jdbcConnection"/>
    <property name="statementConverter">
      <bean class="org.openadaptor.auxil.connector.jdbc.writer.orderedmap.SQLStatementConverter">
        <property name="sql" value="INSERT INTO ERROR_LOG VALUES (NULL,'$timestamp$','$exceptionClass$','$originatingComponent$','$data$','false', 'false')"/>
      </bean>
    </property>
  </bean>
</textarea> 
<br/><br/>


<p>Here is how to run sample adaptors for paragraphs a and c above. For example c look into the file for instructions on setting up the hostpital schema.</p>

<div class="shell"><pre>
  java org.openadaptor.spring.SpringAdaptor -config step11[a|c].xml 
</pre></div>

<br/><br/>

<h3>Exception Handling Summary</h3>
Exception handling was designed with simplicity and flexibility in mind. In basic scenarios all that users need to
do to enable exception handling is to set a file writer as an exceptionProcessor on the Router. More savvy users
have ways of setting up more sofisticated exception handlers and their disposal. Those various ways are not self-exclusive and, if necessary, could be used in combination to suit most complex needs - to create an exceptionProcessor made up of several nodes some of which 
could branch off, include the Message Hospital as well as handle different exception types differently by using the exceptionMap. 

<p class="back"><a href="#contents">back to contents</a></p>



<!--
    Summary
-->
<a name="summary"></a>
<h2>Summary</h2>
<p>This tutorial builds up two adaptor examples that are much more representative than 
the simplistic examples in the example/spring. It does not give a comprehensive view
of all of openadaptor capabilities, you need to refer to the other spring examples and
the java docs.</p>

<p class="back"><a href="#contents">back to contents</a></p>


</body>
</html>
